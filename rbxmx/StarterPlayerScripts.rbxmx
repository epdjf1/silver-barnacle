<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="StarterPlayerScripts" referent="RBX9D550BD307BE4657B6707868D519D9C2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">StarterPlayerScripts</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="LocalScript" referent="RBXC798212B1AE74B9A90D7A08281ABC215">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">PlantClient</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{043AC69D-D215-4289-96AF-A926BC98DD38}</string>
				<ProtectedString name="Source"><![CDATA[-- Version v1.1.1
--[[
  역할: 플레이어가 TomatoSeed(씨앗) 툴을 "장착"한 상태에서
       밭의 Base(PrimaryPart)를 "클릭"하면 서버에 심기 요청(RemoteEvent)을 보냅니다.

  왜 로컬에서 마우스를 읽나요?
   - 마우스 Target/Hit 정보는 클라이언트에서만 쉽게 얻을 수 있기 때문입니다.
   - 단, 최종 검증은 반드시 서버가 수행합니다(치트 방지).
--]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")

local player = Players.LocalPlayer
local mouse = player:GetMouse()

local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local PlantRequest = Remotes:WaitForChild("PlantRequest")
-- HarvestRequest는 3초만 기다리고 없으면 nil 처리(서버 보장 스크립트가 만들도록)
local HarvestRequest = Remotes:WaitForChild("HarvestRequest", 3) or Remotes:FindFirstChild("HarvestRequest")


-- 현재 장착된 씨앗 툴 이름(없으면 nil)
local equippedSeedToolName: string? = nil

-- 툴 장착/해제 감지
local function onToolEquipped(tool)
	-- 씨앗 툴 판단: 내부에 StringValue CropType 존재
	local cropType = tool:FindFirstChild("CropType")
	if cropType and cropType:IsA("StringValue") then
		equippedSeedToolName = tool.Name
	else
		equippedSeedToolName = nil
	end
end

local function onToolUnequipped(tool)
	if tool.Name == equippedSeedToolName then
		equippedSeedToolName = nil
	end
end

-- 캐릭터 로드 시 툴 이벤트 연결
local function hookCharacter(char)
	-- 현재 들고 있는 툴 체크
	for _, t in ipairs(char:GetChildren()) do
		if t:IsA("Tool") then
			t.Equipped:Connect(function() onToolEquipped(t) end)
			t.Unequipped:Connect(function() onToolUnequipped(t) end)
		end
	end
	-- 이후 새로 든 툴도 대응
	char.ChildAdded:Connect(function(obj)
		if obj:IsA("Tool") then
			obj.Equipped:Connect(function() onToolEquipped(obj) end)
			obj.Unequipped:Connect(function() onToolUnequipped(obj) end)
		end
	end)
end

if player.Character then hookCharacter(player.Character) end
player.CharacterAdded:Connect(hookCharacter)

-- Version 1.2
--[[
  변경점:
   ▪ 클릭 수확(클라→서버 Remote) 제거
   ▪ 씨앗 장착 시 '밭 클릭=심기'만 처리
   ▪ 수확은 오직 ProximityPrompt(E, 홀드)로만 수행
--]]
mouse.Button1Down:Connect(function()
	local target = mouse.Target
	if not target then return end

	-- [심기] 씨앗 툴 장착 상태에서만 처리
	if not equippedSeedToolName then
		return -- 수확은 E 프롬프트로만!
	end

	local plots = workspace:FindFirstChild("Plots")
	if not plots then return end
	local plotModel = target:FindFirstAncestorOfClass("Model")
	if not plotModel or plotModel.Parent ~= plots then return end

	-- 서버: 심기 요청
	PlantRequest:FireServer(equippedSeedToolName, target, mouse.Hit.Position)
end)
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX25EF85330C734572B688A158218A1A5D">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">TreeHealthUI</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{F3666A5D-9428-4A72-B8CD-F717800B47EE}</string>
				<ProtectedString name="Source"><![CDATA[-- Version 1.0
-- TreeHealthUI: 모든 나무(Model)에 체력바를 부착/갱신하는 클라이언트 스크립트
-- 초보 설명:
--  - 서버가 나무에 붙여둔 Attribute(HP, MaxHP, TreeState)를 감지해 체력바를 보여줍니다.
--  - 성장중(Growing) 또는 HP==0이면 숨기고, 성목(Mature)이면 보입니다.

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local HealthBar3D = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("UI"):WaitForChild("HealthBar3D"))

local TreesFolder = workspace:WaitForChild("Trees", 5) or workspace

local function shouldAttach(model: Instance)
	return model:IsA("Model") and model:GetAttribute("TreeState") ~= nil
end

local attached = {}  -- [model] = gui

local function refresh(model: Model)
	local gui = attached[model] or HealthBar3D.Attach(model)
	if not gui then return end
	attached[model] = gui

	local hp = model:GetAttribute("HP") or 0
	local max = model:GetAttribute("MaxHP") or 3
	local state = model:GetAttribute("TreeState")

	HealthBar3D.Update(gui, hp, max)
	HealthBar3D.SetVisible(gui, state == "Mature" and hp > 0)
end

local function hook(model: Model)
	if not shouldAttach(model) then return end
	if attached[model] then return end
	refresh(model)

	-- 변화 감지
	model:GetAttributeChangedSignal("HP"):Connect(function() refresh(model) end)
	model:GetAttributeChangedSignal("MaxHP"):Connect(function() refresh(model) end)
	model:GetAttributeChangedSignal("TreeState"):Connect(function() refresh(model) end)

	model.AncestryChanged:Connect(function(_, parent)
		if not parent then
			local gui = attached[model]
			if gui then gui:Destroy() end
			attached[model] = nil
		end
	end)
end

-- 초기 부착 + 이후 추가되는 나무
for _, m in ipairs(TreesFolder:GetChildren()) do hook(m) end
TreesFolder.ChildAdded:Connect(function(m) hook(m) end)
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX686ABBBF072B4E3EBFFF69795ED1EA78">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ShopClient</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{DB688FF9-B0CF-4D86-BAC1-A94E46EE6EBA}</string>
				<ProtectedString name="Source"><![CDATA[-- Version 1.1	
-- ShopClient: E키(ShopPrompt)로 상점 UI 열기 + 품목 동적 생성 + 서버에 Buy/Sell 요청
-- 초보설명:
--  - UI는 코드로 즉석 생성(ScreenGui) → 깔끔히 파괴/재생성.
--  - RemoteFunction으로 결과 받아서 즉시 갱신.

-- Version 1.1 (참조부)
-- RemoteEvent 구조에 맞춰 안전하게 참조합니다.
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ProximityPromptService = game:GetService("ProximityPromptService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")

-- Shared/Config 로드 (로드 순서 이슈 방지)
local Shared = ReplicatedStorage:WaitForChild("Shared")
local Config = require(Shared:WaitForChild("ShopConfig"))

-- Remotes/Shop/Buy Sell은 RemoteEvent
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local ShopFolder = Remotes:WaitForChild("Shop")
local BuyRemote  = ShopFolder:WaitForChild("Buy")  :: RemoteEvent
local SellRemote = ShopFolder:WaitForChild("Sell") :: RemoteEvent

local localPlayer = Players.LocalPlayer

-- 간단 UI 빌더
local function buildUI()
	local gui = Instance.new("ScreenGui")
	gui.Name = "ShopGui"
	gui.ResetOnSpawn = false
	gui.IgnoreGuiInset = true
	gui.Enabled = false

	local root = Instance.new("Frame")
	root.Name = "Root"
	root.BackgroundColor3 = Color3.fromRGB(20,20,24)
	root.BackgroundTransparency = 0.1
	root.Size = UDim2.fromScale(0.42, 0.52)
	root.Position = UDim2.fromScale(0.29, 0.24)
	root.Parent = gui

	local title = Instance.new("TextLabel")
	title.Text = "상점"
	title.Font = Enum.Font.GothamBold
	title.TextSize = 20
	title.TextColor3 = Color3.new(1,1,1)
	title.BackgroundTransparency = 1
	title.Size = UDim2.new(1, -40, 0, 36)
	title.Position = UDim2.new(0, 20, 0, 10)
	title.Parent = root

	local close = Instance.new("TextButton")
	close.Text = "X"
	close.Font = Enum.Font.GothamBold
	close.TextSize = 16
	close.TextColor3 = Color3.new(1,1,1)
	close.BackgroundColor3 = Color3.fromRGB(60,60,70)
	close.Size = UDim2.fromOffset(30, 30)
	close.Position = UDim2.new(1, -40, 0, 10)
	close.Parent = root

	local money = Instance.new("TextLabel")
	money.Name = "Money"
	money.Text = "Coins: 0"
	money.Font = Enum.Font.Gotham
	money.TextSize = 16
	money.TextXAlignment = Enum.TextXAlignment.Left
	money.TextColor3 = Color3.fromRGB(190,255,190)
	money.BackgroundTransparency = 1
	money.Size = UDim2.new(1, -40, 0, 20)
	money.Position = UDim2.new(0, 20, 0, 46)
	money.Parent = root

	local list = Instance.new("ScrollingFrame")
	list.Name = "List"
	list.BackgroundTransparency = 0.2
	list.BackgroundColor3 = Color3.fromRGB(32,32,38)
	list.Size = UDim2.new(1, -40, 1, -90)
	list.Position = UDim2.new(0, 20, 0, 76)
	list.AutomaticCanvasSize = Enum.AutomaticSize.Y
	list.CanvasSize = UDim2.new()
	list.ScrollBarThickness = 6
	list.Parent = root

	local uiList = Instance.new("UIListLayout")
	uiList.Padding = UDim.new(0, 8)
	uiList.Parent = list

	-- 품목 버튼 생성
	for _, it in ipairs(Config.Items) do
		local row = Instance.new("Frame")
		row.Size = UDim2.new(1, -10, 0, 56)                 -- ★ 행 높이↑
		row.BackgroundColor3 = Color3.fromRGB(40,40,50)
		row.Parent = list
		
		--V1.0.2
		local name = Instance.new("TextLabel")
		name.BackgroundTransparency = 1
		name.Text = it.name
		name.Font = Enum.Font.Gotham
		name.TextSize = 16
		name.TextXAlignment = Enum.TextXAlignment.Left
		name.TextColor3 = Color3.fromRGB(235, 235, 235)  -- ★ 밝은 글자색
		name.TextStrokeTransparency = 0.5                 -- (선택) 테두리로 가독성↑
		name.ZIndex = 2                                   -- 버튼 위에 오도록(안전)
		name.Size = UDim2.new(0.5, -10, 1, 0)
		name.Position = UDim2.new(0, 10, 0, 0)
		name.Parent = row


		local buyBtn = Instance.new("TextButton")
		buyBtn.Text = it.buy and ("구매 +"..it.buy) or "구매불가"
		buyBtn.AutoButtonColor = it.buy ~= nil
		buyBtn.BackgroundColor3 = it.buy and Color3.fromRGB(66,194,105) or Color3.fromRGB(70,70,70)
		buyBtn.TextColor3 = Color3.new(0,0,0)
		buyBtn.Font = Enum.Font.GothamBold
		buyBtn.TextSize = 20                               -- ★ 글자 크게
		buyBtn.Size = UDim2.new(0, 120, 0, 36)             -- (살짝 넓게/높게)
		buyBtn.Position = UDim2.new(1, -250, 0.5, -18)
		buyBtn.Parent = row
		
		-- RemoteEvent는 반환값이 없으므로 FireServer만 호출합니다.
		buyBtn.MouseButton1Click:Connect(function()
			if not it.buy then return end         -- 가격 없으면 구매불가
			buyBtn.Active = false                 -- 과다 연타 방지(선택)
			BuyRemote:FireServer(it.id, 1)        -- ★ InvokeServer(X), FireServer(O)
			task.delay(0.2, function()
				if buyBtn then buyBtn.Active = true end
			end)
		end)


		local sellBtn = Instance.new("TextButton")
		sellBtn.Text = it.sell and ("판매 +"..it.sell) or "판매불가"
		sellBtn.AutoButtonColor = it.sell ~= nil
		sellBtn.BackgroundColor3 = it.sell and Color3.fromRGB(255,210,100) or Color3.fromRGB(70,70,70)
		sellBtn.TextColor3 = Color3.new(0,0,0)
		sellBtn.Font = Enum.Font.GothamBold
		sellBtn.TextSize = 20                               -- ★ 글자 크게
		sellBtn.Size = UDim2.new(0, 120, 0, 36)
		sellBtn.Position = UDim2.new(1, -120, 0.5, -18)
		sellBtn.Parent = row

		sellBtn.MouseButton1Click:Connect(function()
			if not it.sell then return end
			sellBtn.Active = false                          -- 과다 연타 방지(선택)
			SellRemote:FireServer(it.id, 1)                 -- ★ InvokeServer → FireServer
			task.delay(0.2, function()
				if sellBtn then sellBtn.Active = true end
			end)
			-- 코인 라벨은 Attribute 변화를 통해 자동 갱신됨(updateCoins 연결)
		end)

	end

	-- 닫기
	close.MouseButton1Click:Connect(function() gui.Enabled = false end)
	UserInputService.InputBegan:Connect(function(inp, gp)
		if gp then return end
		if inp.KeyCode == Enum.KeyCode.Escape then
			gui.Enabled = false
		end
	end)

	gui.Parent = localPlayer:WaitForChild("PlayerGui")
	return gui
end

local gui = buildUI()

-- 코인 표시 실시간 업데이트
local function updateCoins()
	local v = localPlayer:GetAttribute(Config.CurrencyName) or 0
	local lbl = gui.Root.Money
	lbl.Text = ("Coins: %d"):format(v)
end
localPlayer:GetAttributeChangedSignal(Config.CurrencyName):Connect(updateCoins)
task.defer(updateCoins)

-- E키 상호작용(ShopPrompt)로 열기
ProximityPromptService.PromptTriggered:Connect(function(prompt, plr)
	if plr ~= localPlayer then return end
	if prompt.Name ~= "ShopPrompt" then return end
	gui.Enabled = true
	updateCoins()
end)
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX8F94DE4A84974AAAA62CFC967AE84717">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LootClient</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{ED4223E0-BA6F-4C32-8311-10FDD7D7A3E8}</string>
				<ProtectedString name="Source"><![CDATA[-- Version 1.0
-- LootClient: 서버가 보내는 획득(Picked) 신호를 받아 화면에 아이콘+텍스트를 띄움

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")

local rem = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Loot"):WaitForChild("Picked")
local ItemIcons = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ItemIcons"))

local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")

-- 한 번 만들어 두는 루트 GUI
local screen = Instance.new("ScreenGui")
screen.Name = "LootHud"
screen.IgnoreGuiInset = true
screen.ResetOnSpawn = false
screen.Parent = playerGui

local function showPickup(id: string, qty: number)
	qty = tonumber(qty) or 1
	local frame = Instance.new("Frame")
	frame.BackgroundTransparency = 1
	frame.Size = UDim2.fromOffset(220, 56)
	frame.Position = UDim2.fromScale(0.5, 0.82)
	frame.AnchorPoint = Vector2.new(0.5, 0.5)
	frame.Parent = screen
	frame.ZIndex = 50

	local img = Instance.new("ImageLabel")
	img.BackgroundTransparency = 1
	img.Size = UDim2.fromOffset(44, 44)
	img.Position = UDim2.fromOffset(0, 6)
	img.Image = ItemIcons[id] or ""
	img.Parent = frame
	img.ZIndex = 51

	local txt = Instance.new("TextLabel")
	txt.BackgroundTransparency = 1
	txt.Text = string.format("+%d %s", qty, id)
	txt.Font = Enum.Font.GothamBold
	txt.TextSize = 22
	txt.TextColor3 = Color3.fromRGB(235,235,235)
	txt.TextStrokeTransparency = 0.4
	txt.Size = UDim2.fromOffset(160, 56)
	txt.Position = UDim2.fromOffset(56, 0)
	txt.TextXAlignment = Enum.TextXAlignment.Left
	txt.Parent = frame
	txt.ZIndex = 51

	-- 트윈: 위로 살짝 이동하며 페이드
	local t1 = TweenService:Create(frame, TweenInfo.new(0.18, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Position = UDim2.fromScale(0.5, 0.79)})
	local t2 = TweenService:Create(frame, TweenInfo.new(0.35, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = UDim2.fromScale(0.5, 0.74)})
	local t3 = TweenService:Create(txt, TweenInfo.new(0.25), {TextTransparency = 0.0})
	local f3 = TweenService:Create(frame, TweenInfo.new(0.25), {BackgroundTransparency = 1})

	t1:Play(); t3:Play()
	t1.Completed:Wait()
	t2:Play()
	t2.Completed:Wait()

	-- 사라짐
	local fadeTxt = TweenService:Create(txt, TweenInfo.new(0.25), {TextTransparency = 1})
	local fadeImg = TweenService:Create(img, TweenInfo.new(0.25), {ImageTransparency = 1})
	fadeTxt:Play(); fadeImg:Play()
	fadeImg.Completed:Wait()
	frame:Destroy()
end

rem.OnClientEvent:Connect(function(payload)
	if typeof(payload) ~= "table" then return end
	showPickup(payload.id, payload.qty)
end)
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX799E050FD7474A7BB1660E8E89BFF096">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">HotbarClient</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{C507E13D-5E0B-4D44-A1DF-99E9CB02DE91}</string>
				<ProtectedString name="Source"><![CDATA[-- Version 1.8.0
-- HotbarClient (안정판)
-- 목적(초보 친화 설명):
--  1) 플레이어 인벤토리(LocalPlayer/Inventory : IntValue 집합)와 ReplicatedStorage/Tools의 Tool 프리팹을 읽어
--     하단 단축바(핫바)를 자동 생성/갱신합니다.
--  2) 마우스 클릭과 **상단 숫자키(1~8)** 로 슬롯 선택이 가능합니다. (키패드 사용 안 함)
--     - Tool 계열(도끼, 씨앗 등)은 수량이 0이라도 장착 가능(게임 규칙에 따라 장착만).
--     - 비장착 아이템(예: Wood)은 선택/하이라이트만 하고 실제 착용은 하지 않습니다.
--  3) "첫 슬롯만 장착" 문제를 방지하기 위해
--     - 반복문 클로저 캡처 주의(로컬 복사),
--     - 화면 순서(order) 기반 인덱싱 고정,
--     - ContextActionService 우선순위 상향 + 폴백(InputBegan) 처리,
--     - 리스폰(CharacterAdded) 시 자동 재바인딩 을 적용했습니다.
--
-- 용어 풀이:
--  - Inventory(IntValue): 각 아이템 이름(예: "TomatoSeed")을 가진 IntValue. 수량을 나타냅니다.
--  - Tools 폴더: ReplicatedStorage.Tools 밑 Tool 프리팹(장착 가능한 아이템).
--  - ItemDefs 모듈(있으면 사용): 아이템에 대한 정의 테이블 { equip=true/false, ... }.
--    없으면 Tools 폴더 존재 여부로 equip 가능 여부를 자동 추론합니다.

DEBUG = true  -- 디버그 출력(텍스트). Studio Output에서 동작 확인에 사용.

--// 서비스 참조
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ContextActionService = game:GetService("ContextActionService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService") -- (향후 슬롯 애니메이션용)

local LOCAL_PLAYER = Players.LocalPlayer

-- 기본 백팩 UI가 숫자키를 선점하지 않도록 비활성화(안전하게 pcall)
pcall(function()
	game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
end)

-- ===== 설정 =====
-- v1.4.2: 상단 숫자키(1~8)만 사용
local MAX_KEYS = 8
local KEYCODES = {
	Enum.KeyCode.One, Enum.KeyCode.Two, Enum.KeyCode.Three, Enum.KeyCode.Four,
	Enum.KeyCode.Five, Enum.KeyCode.Six, Enum.KeyCode.Seven, Enum.KeyCode.Eight,
}

-- ===== 외부 의존(있으면 사용, 없으면 자동 추론) =====
local Shared = ReplicatedStorage:FindFirstChild("Shared")
local ItemDefsModule = Shared and Shared:FindFirstChild("ItemDefs")
local okDefs, ItemDefs = pcall(function() return ItemDefsModule and require(ItemDefsModule) end)
if not okDefs then ItemDefs = nil end

local ToolsFolder = ReplicatedStorage:FindFirstChild("Tools")

local IconsModule = Shared and Shared:FindFirstChild("ItemIcons")
local okIcons, ItemIcons = pcall(function() return IconsModule and require(IconsModule) end)
if not okIcons then ItemIcons = {} end

-- 최신 FontFace만 사용 (경고 제거)
local function setSemiBoldFont(label: TextLabel)
	label.FontFace = Font.new(
		"rbxasset://fonts/families/GothamSSm.json",
		Enum.FontWeight.SemiBold,
		Enum.FontStyle.Normal
	)
end

-- v1.7.0 ⭐추가: 버튼에 '호버 테두리'를 부착하는 유틸
--  - UIStroke: 기본은 투명(보이지 않음), 마우스 진입 시만 살짝 표시
--  - UICorner: 모서리 둥글게(슬롯 미관 개선)
local function attachHoverStroke(button: GuiObject)
	local stroke = Instance.new("UIStroke")
	stroke.Name = "HoverStroke"
	stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	stroke.Thickness = 2
	stroke.Color = Color3.fromRGB(255, 255, 255)
	stroke.Transparency = 1 -- 평소엔 숨김
	stroke.Parent = button

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = button

	button.MouseEnter:Connect(function()
		stroke.Transparency = 0.4 -- 호버 시 은은한 테두리
	end)
	button.MouseLeave:Connect(function()
		stroke.Transparency = 1
	end)
end

-- ===== 내부 상태 =====
local screenGui : ScreenGui
local barFrame : Frame
local slotButtons : {ImageButton} = {}
local slotCountTexts : {TextLabel} = {}
local order : {string} = {}         -- 화면에 보이는 순서대로의 itemId 리스트
local slotById : {[string]: {valueObj: IntValue?, last: number}} = {}
local equippedId : string? = nil     -- 현재 장착 중인 Tool 이름(또는 nil)


-- v1.5.0 ⭐추가: 획득 순서(세션 내 고정)용 Attribute 키
local ORDER_ATTR = "HB_Order"
local NEXT_ORDER_ATTR = "HB_NextOrder"

-- v1.5.0 ⭐추가: 다음 순번 확보(없으면 1부터 시작)
local function ensureNextOrderAttr(inv: Instance): number
	local n = inv:GetAttribute(NEXT_ORDER_ATTR)
	if typeof(n) ~= "number" then
		inv:SetAttribute(NEXT_ORDER_ATTR, 1)
		n = 1
	end
	return n
end

-- v1.5.0 ⭐추가: 아이템(IntValue)에 최초 등장시만 순번 부여
local function assignOrderIfNeeded(inv: Instance, vobj: IntValue)
	if vobj:GetAttribute(ORDER_ATTR) then return end
	local nextIdx = ensureNextOrderAttr(inv)
	vobj:SetAttribute(ORDER_ATTR, nextIdx)         -- 이 아이템의 순서 확정
	inv:SetAttribute(NEXT_ORDER_ATTR, nextIdx + 1) -- 다음 순서 증가
	if DEBUG then
		warn(("HotbarClient v1.5.0: assign order %d to %s"):format(nextIdx, vobj.Name))
	end
end

-- (선언만 먼저: 일부 콜백에서 참조)
-- v1.4.2a 교체: 중복 정의 방지. '함수 정의'가 아니라 '변수 전방 선언'만 남깁니다.
local equipByIndex -- : (idx: number) -> ()  -- 타입 느낌의 주석일 뿐, 실제 문법 영향 없음

-- v1.6.1 ⭐추가: buildEmptySlot에서 사용하므로 전방 선언만 먼저
local unequipAll   -- : () -> ()
local highlightIndex -- : (idx: number?) -> ()

-- ===== 유틸 =====
local function getItemDef(id: string)
	if ItemDefs and ItemDefs[id] then
		return ItemDefs[id]
	end
	local def = {}
	def.equip = (ToolsFolder and ToolsFolder:FindFirstChild(id)) and true or false
	return def
end

-- v1.9.0 ⭐추가: 아이템 표시 이름 헬퍼
--  - ItemDefs[id].displayName 가 있으면 그것을, 없으면 원래 id 사용
local function getDisplayName(id: string): string
	local d = (ItemDefs and ItemDefs[id]) or nil
	if d and typeof(d.displayName) == "string" and #d.displayName > 0 then
		return d.displayName
	end
	return id
end

-- GUI 생성(한 번만)
local function ensureGui()
	if screenGui then return end

	screenGui = Instance.new("ScreenGui")
	screenGui.Name = "HotbarGui"
	screenGui.ResetOnSpawn = false
	screenGui.IgnoreGuiInset = true
	screenGui.Parent = LOCAL_PLAYER:WaitForChild("PlayerGui")

	-- 하단 중앙 정렬용 프레임(너비는 아이템 수에 따라 동적)
	barFrame = Instance.new("Frame")
	barFrame.Name = "Bar"
	barFrame.AnchorPoint = Vector2.new(0.5, 1)
	barFrame.Position = UDim2.new(0.5, 0, 1, -12)
	barFrame.Size = UDim2.new(0, 0, 0, 64) -- 실제 너비는 rebuild 시 계산
	barFrame.BackgroundTransparency = 1
	barFrame.Parent = screenGui
end

-- 슬롯 버튼 하나 생성
-- v1.8.0 교체: 아이템 슬롯도 키캡 표시 + 회색 배경 유지 + 아이콘만 얹기
-- v1.9.0 교체: 중앙 이름 라벨(ItemName) 추가 + 기존 스타일 유지
local function buildSlot(idx: number, id: string, count: number)
	-- 버튼 본체(배경은 항상 회색 유지)
	local btn = Instance.new("ImageButton")
	btn.Name = ("Slot_%d"):format(idx)
	btn.Size = UDim2.new(0, 56, 0, 56)
	btn.Position = UDim2.new(0, (idx-1)*60, 0, 4)
	btn.AutoButtonColor = true
	btn.BackgroundColor3 = Color3.fromRGB(40,40,40)
	btn.BackgroundTransparency = 0
	btn.BorderSizePixel = 0
	btn.Image = ""
	btn.Parent = barFrame

	attachHoverStroke(btn) -- 호버 테두리

	-- 아이콘(있으면 내부 ImageLabel로만 표시, 여백 포함)
	local iconId = ItemIcons[id]
	local hasIcon = (typeof(iconId) == "string" and #iconId > 0)
	if hasIcon then
		local icon = Instance.new("ImageLabel")
		icon.Name = "Icon"
		icon.BackgroundTransparency = 1
		icon.Size = UDim2.new(1, -10, 1, -10)  -- 패딩 5px
		icon.Position = UDim2.new(0, 5, 0, 5)
		icon.Image = iconId
		icon.ScaleType = Enum.ScaleType.Fit
		icon.ZIndex = 1
		icon.Parent = btn
	end
	-- (아이콘이 없어도 이제는 중앙 이름 라벨을 사용하므로, 이전의 상단 이름 라벨은 만들지 않습니다)

	-- 상단 좌측: 회색 키캡(슬롯 번호)
	local keycap = Instance.new("TextLabel")
	keycap.Name = "Keycap"
	keycap.BackgroundTransparency = 1
	keycap.Size = UDim2.new(0, 16, 0, 14)
	keycap.Position = UDim2.new(0, 4, 0, 2)
	keycap.Text = tostring(idx)
	keycap.TextColor3 = Color3.fromRGB(180,180,180)
	keycap.TextScaled = true
	setSemiBoldFont(keycap)
	keycap.ZIndex = 3
	keycap.Parent = btn

	-- ★ v1.9.0 추가: 중앙 이름 라벨(아이템 표시 이름)
	local nameMid = Instance.new("TextLabel")
	nameMid.Name = "ItemName"
	nameMid.BackgroundTransparency = 1
	nameMid.AnchorPoint = Vector2.new(0.5, 0.5)
	nameMid.Position = UDim2.new(0.5, 0, 0.5, 0)           -- 정확히 중앙
	nameMid.Size = UDim2.new(2, -8, 0, 40)                 -- 가로 여백 4px씩
	nameMid.Text = getDisplayName(id)                      -- 표시에 더 예쁜 이름
	nameMid.TextColor3 = Color3.fromRGB(235,235,235)       -- 밝은 회색
	nameMid.TextStrokeTransparency = 0.4                   -- 외곽선으로 가독성 ↑
	nameMid.TextScaled = true                              -- 길면 자동 축소
	nameMid.TextWrapped = false
	nameMid.ZIndex = 3                                     -- 아이콘 위
	setSemiBoldFont(nameMid)
	nameMid.Parent = btn

	-- 우하단 수량
	local t = Instance.new("TextLabel")
	t.Name = "Count"
	t.AnchorPoint = Vector2.new(1,1)
	t.Position = UDim2.new(1, -4, 1, -4)
	t.Size = UDim2.new(0, 36, 0, 18)
	t.BackgroundTransparency = 1
	t.TextColor3 = Color3.new(1,1,1)
	t.TextStrokeTransparency = 0.5
	t.TextScaled = true
	setSemiBoldFont(t)
	t.Text = tostring(count or 0)
	t.ZIndex = 3
	t.Parent = btn

	-- 선택 하이라이트(하단 바)
	local hl = Instance.new("Frame")
	hl.Name = "HL"
	hl.BackgroundColor3 = Color3.fromRGB(255, 170, 60)
	hl.BackgroundTransparency = 0.5
	hl.BorderSizePixel = 0
	hl.Size = UDim2.new(1, 0, 0, 3)
	hl.Position = UDim2.new(0, 0, 1, -3)
	hl.Visible = false
	hl.ZIndex = 4
	hl.Parent = btn

	slotButtons[idx] = btn
	slotCountTexts[idx] = t

	-- 클릭 핸들러
	local idxCopy = idx
	btn.MouseButton1Click:Connect(function()
		equipByIndex(idxCopy)
	end)
end


-- v1.6.0 ⭐추가: 아이템이 없는 빈 칸 슬롯(플레이스홀더) 생성
--  - 클릭 시 장착 해제(unequipAll)만 수행, 하이라이트 없음
local function buildEmptySlot(idx: number)
	local btn = Instance.new("ImageButton")
	btn.Name = ("Slot_%d_Empty"):format(idx)
	btn.Size = UDim2.new(0, 56, 0, 56)
	btn.Position = UDim2.new(0, (idx-1)*60, 0, 4)
	btn.AutoButtonColor = false
	btn.BackgroundColor3 = Color3.fromRGB(40,40,40)
	btn.BorderSizePixel = 0
	btn.Image = ""
	btn.Parent = barFrame
	
	-- v1.7.0 ⭐추가: 호버 테두리(아이템 슬롯과 동일)
	attachHoverStroke(btn)

	-- 그래도 일관성을 위해 HL 프레임은 만들어 두되, 사용할 일은 없음
	local hl = Instance.new("Frame")
	hl.Name = "HL"
	hl.BackgroundColor3 = Color3.fromRGB(255, 170, 60)
	hl.BackgroundTransparency = 0.5
	hl.BorderSizePixel = 0
	hl.Size = UDim2.new(1, 0, 0, 3)
	hl.Position = UDim2.new(0, 0, 1, -3)
	hl.Visible = false
	hl.Parent = btn
	
	-- v1.7.0 ⭐추가: 좌측 상단 작은 회색 숫자 키캡(1~8)
	local keycap = Instance.new("TextLabel")
	keycap.Name = "Keycap"
	keycap.BackgroundTransparency = 1
	keycap.Size = UDim2.new(0, 16, 0, 14) -- 작고 깔끔하게
	keycap.Position = UDim2.new(0, 4, 0, 2)
	keycap.Text = tostring(idx)
	keycap.TextColor3 = Color3.fromRGB(180,180,180) -- 회색
	keycap.TextScaled = true
	setSemiBoldFont(keycap)
	keycap.Parent = btn

	slotButtons[idx] = btn
	slotCountTexts[idx] = nil

	btn.MouseButton1Click:Connect(function()
		-- 빈 슬롯 클릭 시: 모든 장착 해제 + 하이라이트 해제
		unequipAll()
		highlightIndex(nil)
	end)
end

-- 바 프레임 초기화(모든 슬롯 제거)
local function clearBar()
	for _,b in ipairs(slotButtons) do
		if b then b:Destroy() end
	end
	slotButtons = {}
	slotCountTexts = {}
end

-- 모든 Tool 해제 + 하이라이트 끄기
-- 모든 Tool 해제 + 하이라이트 끄기
-- v1.6.1 교체: 위 전방 선언(local unequipAll)에 '대입'되도록 local 제거
function unequipAll()
	local char = LOCAL_PLAYER.Character
	local hum = char and char:FindFirstChildOfClass("Humanoid")
	if hum then hum:UnequipTools() end
	equippedId = nil
	for _,btn in ipairs(slotButtons) do
		local hl = btn and btn:FindFirstChild("HL")
		if hl then hl.Visible = false end
	end
end


-- 특정 슬롯만 하이라이트
-- v1.6.1 교체: 위 전방 선언(local highlightIndex)에 '대입'되도록 local 제거
function highlightIndex(idx: number?)
	for i,btn in ipairs(slotButtons) do
		local hl = btn and btn:FindFirstChild("HL")
		if hl then hl.Visible = (idx ~= nil and i == idx) end
	end
end

-- Tool 장착(Backpack에 없으면 Tools 프리팹에서 복제하여 지급 후 장착)
local function equipToolById(id: string)
	local def = getItemDef(id)
	if not def or not def.equip then return false end

	unequipAll()

	local backpack = LOCAL_PLAYER:WaitForChild("Backpack")
	local char = LOCAL_PLAYER.Character
	local hum = char and char:FindFirstChildOfClass("Humanoid")

	local tool = (backpack:FindFirstChild(id)) or (char and char:FindFirstChild(id))
	if not tool then
		local prefab = ToolsFolder and ToolsFolder:FindFirstChild(id)
		if prefab then
			tool = prefab:Clone()
			tool.Parent = backpack
		else
			return false
		end
	end

	if hum then
		hum:EquipTool(tool)
		equippedId = id
		return true
	end
	return false
end

-- 화면 순서(order)에 맞춰 전체 UI 재구성
local function rebuildOrderAndUI()
	ensureGui()
	order = {}

	-- 인벤토리 확보(없으면 생성)
	local inv = LOCAL_PLAYER:FindFirstChild("Inventory")
	if not inv then
		inv = Instance.new("Folder")
		inv.Name = "Inventory"
		inv.Parent = LOCAL_PLAYER
	end

	-- v1.6.0 교체: 8칸을 항상 표시(아이템 없는 칸은 빈 슬롯) + 중앙 정렬 폭 고정
	local entries = {}
	for _,v in ipairs(inv:GetChildren()) do
		if v:IsA("IntValue") then
			local id = v.Name
			local def = getItemDef(id)
			local count = v.Value or 0
			-- 장착 불가 아이템은 수량 0이면 표시 X (규칙 유지)
			if (def.equip) or (count > 0) then
				assignOrderIfNeeded(inv, v) -- 최초 본 아이템이면 순번 부여
				local ord = v:GetAttribute(ORDER_ATTR) or math.huge
				table.insert(entries, { id = id, ord = ord })
				slotById[id] = { valueObj = v, last = count }
			end
		end
	end

	table.sort(entries, function(a,b)
		if a.ord ~= b.ord then return a.ord < b.ord end
		return a.id < b.id
	end)

	clearBar()

	-- ⭐폭을 MAX_KEYS 기준으로 고정 → 항상 중앙
	local SLOT_W, GAP = 56, 4
	local PITCH = SLOT_W + GAP
	local totalW = (MAX_KEYS * PITCH) - GAP
	barFrame.Size = UDim2.new(0, totalW, 0, 64)

	-- ⭐슬롯 1~MAX_KEYS까지 생성: 앞에서부터 아이템 → 나머지는 빈칸
	order = {} -- 아이템만 연속으로 담는다(빈칸은 넣지 않음)
	for i = 1, MAX_KEYS do
		local e = entries[i]
		if e then
			local id = e.id
			table.insert(order, id) -- 1..#items 연속
			local vobj = slotById[id] and slotById[id].valueObj
			local cnt = (vobj and vobj.Value) or 0
			buildSlot(i, id, cnt)
		else
			buildEmptySlot(i)
		end
	end


end

-- 슬롯 인덱스로 선택/장착
function equipByIndex(idx: number)
	local id = order[idx]
	if not id then
		unequipAll()
		return
	end

	local def = getItemDef(id)
	if def.equip then
		if equipToolById(id) then
			highlightIndex(idx)
		else
			unequipAll()
		end
	else
		unequipAll()
		highlightIndex(idx)
	end
end

-- 인벤토리 수량 변화 감지 → 텍스트만 갱신, 필요 시 전체 리빌드
local function onInventoryChanged()
	local inv = LOCAL_PLAYER:FindFirstChild("Inventory")
	if not inv then return end

	-- 수량 텍스트 갱신
	for idx,id in ipairs(order) do
		local vobj = inv:FindFirstChild(id)
		if vobj and vobj:IsA("IntValue") then
			local cnt = vobj.Value
			local lbl = slotCountTexts[idx]
			if lbl then lbl.Text = tostring(cnt) end
			if slotById[id] then slotById[id].last = cnt end
		end
	end

	-- 표시/숨김 조건 변동 체크
	local needRebuild = false
	for _,v in ipairs(inv:GetChildren()) do
		if v:IsA("IntValue") then
			local id = v.Name
			local def = getItemDef(id)
			local cnt = v.Value
			if not def.equip and cnt <= 0 then
				needRebuild = true
			end
		end
	end
	if needRebuild then
		rebuildOrderAndUI()
	end
end

-- 인벤토리 감시 시작(ChildAdded/Removed/Changed)
-- v1.5.0 교체: 초기 스캔 때도 순서 부여, ChildAdded 때도 즉시 부여
local function startInventoryWatch()
	local inv = LOCAL_PLAYER:FindFirstChild("Inventory")
	if not inv then
		inv = Instance.new("Folder"); inv.Name = "Inventory"; inv.Parent = LOCAL_PLAYER
	end

	-- 다음 순번 보장(없으면 1)
	ensureNextOrderAttr(inv)

	-- 초기 아이템에도 순서 없으면 부여
	for _,v in ipairs(inv:GetChildren()) do
		if v:IsA("IntValue") then
			assignOrderIfNeeded(inv, v) -- ⭐처음 로드 시에도 순서 확정
		end
	end

	rebuildOrderAndUI()

	inv.ChildAdded:Connect(function(ch)
		if ch:IsA("IntValue") then
			assignOrderIfNeeded(inv, ch) -- ⭐새로 들어온 아이템에 순서 확정
			rebuildOrderAndUI()
			ch.Changed:Connect(onInventoryChanged)
		end
	end)

	inv.ChildRemoved:Connect(function(_ch)
		rebuildOrderAndUI()
	end)

	for _,v in ipairs(inv:GetChildren()) do
		if v:IsA("IntValue") then
			v.Changed:Connect(onInventoryChanged)
		end
	end
end


-- ===== 숫자키 바인딩(핵심) =====
-- v1.4.2: 상단 숫자키만 바인딩 + 폴백도 상단 숫자키만 검사
local _fallbackConn : RBXScriptConnection? = nil

local function bindNumberKeys()
	-- 1) 기존 바인딩 해제
	for i = 1, MAX_KEYS do
		local actionName = ("Hotbar_%d"):format(i)
		pcall(function() ContextActionService:UnbindAction(actionName) end)
	end
	if _fallbackConn then _fallbackConn:Disconnect() _fallbackConn = nil end

	-- 2) 컨텍스트 액션(우선순위 높음)으로 상단 숫자키 1:1 바인딩
	for i = 1, MAX_KEYS do
		local actionName = ("Hotbar_%d"):format(i)
		local idxCopy = i
		local keycode = KEYCODES[i]
		if keycode then
			local priority = Enum.ContextActionPriority.High.Value + 1500
			ContextActionService:BindActionAtPriority(
				actionName,
				function(_, state, _input)
					-- 채팅/텍스트박스 포커스면 통과
					if UserInputService:GetFocusedTextBox() then
						return Enum.ContextActionResult.Pass
					end
					if state ~= Enum.UserInputState.Begin then
						return Enum.ContextActionResult.Pass
					end
					if DEBUG then
						warn(("HotbarClient v1.4.2: key -> slot %d"):format(idxCopy))
					end
					equipByIndex(idxCopy)
					return Enum.ContextActionResult.Sink
				end,
				false,
				priority,
				keycode -- 상단 숫자키만
			)
		end
	end

	-- 3) 폴백: 드물게 선점된 경우를 대비 (상단 숫자키만 체크)
	-- v1.4.3 교체: 폴백을 "항상" 받도록 강화(게임처리 여부 무시) + 키보드 입력만 필터
	_fallbackConn = UserInputService.InputBegan:Connect(function(input: InputObject, _gameProcessed: boolean)
		-- 채팅/입력란이 포커스면 통과 (채팅 타이핑 보호)
		if UserInputService:GetFocusedTextBox() then return end
		-- 키보드 입력만 처리 (패드/마우스 등 제외)
		if input.UserInputType ~= Enum.UserInputType.Keyboard then return end

		local kc = input.KeyCode
		for i = 1, MAX_KEYS do
			local keycode = KEYCODES[i]
			if keycode and kc == keycode then
				if DEBUG then
					warn(("HotbarClient v1.4.3 (fallback-force): key -> slot %d"):format(i))
				end
				equipByIndex(i)
				return
			end
		end
	end)


	if DEBUG then
		warn("HotbarClient v1.4.2: number-key bindings (top row) are (re)applied.")
	end
end

-- ===== 시작 =====
ensureGui()
startInventoryWatch()
bindNumberKeys()

-- 리스폰 시 PlayerModule가 입력을 다시 세팅할 수 있어, 다음 틱에 재바인딩
LOCAL_PLAYER.CharacterAdded:Connect(function()
	task.defer(bindNumberKeys)
end)
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBXBB10F0A1EB0E4C939C0D5AE865A0359E">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">HideRobloxHotbar</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{89CF32E9-BBD5-4AAF-9891-3078BA44E7EE}</string>
				<ProtectedString name="Source"><![CDATA[-- Version 1.0
-- HideRobloxHotbar: Roblox 기본 Backpack UI/핫키 차단 + 우리 커스텀 핫바만 사용
-- 초보 설명:
--  - SetCoreGuiEnabled(Backpack,false)로 기본 핫바 UI를 숨깁니다.
--  - ContextActionService로 숫자키(1~8,0)를 '먹어서' 도구 자동장착을 막습니다.

local StarterGui = game:GetService("StarterGui")
local ContextActionService = game:GetService("ContextActionService")
local Players = game:GetService("Players")

local LOCAL = Players.LocalPlayer

-- 1) 기본 핫바 UI 숨김
local function hideCoreGui()
	pcall(function()
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
	end)
end

-- 2) 숫자키 장착 차단 (우선순위 높게)
local BLOCK_ACTION = "BlockToolHotkeys"
local KEYS = {
	Enum.KeyCode.One, Enum.KeyCode.Two, Enum.KeyCode.Three, Enum.KeyCode.Four,
	Enum.KeyCode.Five, Enum.KeyCode.Six, Enum.KeyCode.Seven, Enum.KeyCode.Eight,
	Enum.KeyCode.Zero, -- (원한다면 Nine도 추가)
}
local function blockToolHotkeys()
	ContextActionService:UnbindAction(BLOCK_ACTION)
	ContextActionService:BindActionAtPriority(
		BLOCK_ACTION,
		function() return Enum.ContextActionResult.Sink end,
		false,
		10_000, -- 높은 우선순위로 CoreScript보다 먼저 잡아먹기
		table.unpack(KEYS)
	)
end

-- 초기/리스폰 시 재적용
hideCoreGui()
blockToolHotkeys()
LOCAL.CharacterAdded:Connect(function()
	task.defer(hideCoreGui)
	task.defer(blockToolHotkeys)
end)
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX866D8F120B75486FA01D62401AFF9FFF">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">InventoryClient</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{1AC4D436-F788-41C3-9C97-BDE6C3B0DD9B}</string>
				<ProtectedString name="Source"><![CDATA[-- Version 1.0.2
-- InventoryClient: `키로 여닫는 인벤토리(그리드) UI. 아이콘+수량 표시(읽기 전용)
-- 초보 설명:
--  - Player/Inventory 값을 읽어 그리드로 보여줍니다.
--  - 아이콘은 Shared/ItemIcons를 사용합니다.

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")

local function requireShared(name)
	local sharedFolder = ReplicatedStorage:FindFirstChild("Shared")
	if sharedFolder and sharedFolder:FindFirstChild(name) then
		return require(sharedFolder[name])
	end
	return require(ReplicatedStorage:WaitForChild(name))
end

local ItemIcons = requireShared("ItemIcons")
local ShopConfig = requireShared("ShopConfig")

local lp = Players.LocalPlayer
local gui = Instance.new("ScreenGui")
gui.Name = "InventoryGui"
gui.IgnoreGuiInset = true
gui.ResetOnSpawn = false
gui.Enabled = false
gui.Parent = lp:WaitForChild("PlayerGui")

local root = Instance.new("Frame")
root.BackgroundColor3 = Color3.fromRGB(20,20,24)
root.BackgroundTransparency = 0.1
root.Size = UDim2.fromScale(0.5, 0.6)
root.Position = UDim2.fromScale(0.25, 0.2)
root.Parent = gui
root.ZIndex = 30

local title = Instance.new("TextLabel")
title.Text = "인벤토리"
title.Font = Enum.Font.GothamBold
title.TextSize = 22
title.TextColor3 = Color3.new(1,1,1)
title.BackgroundTransparency = 1
title.Size = UDim2.new(1, -20, 0, 36)
title.Position = UDim2.new(0, 10, 0, 10)
title.Parent = root

local grid = Instance.new("Frame")
grid.BackgroundTransparency = 1
grid.Size = UDim2.new(1, -20, 1, -60)
grid.Position = UDim2.new(0, 10, 0, 50)
grid.Parent = root

-- v1.0.2: 레이아웃 보장(파괴되었으면 재생성)
local uiGrid : UIGridLayout? = nil
local function ensureGridLayout()
	if uiGrid and uiGrid.Parent == grid then return end
	uiGrid = Instance.new("UIGridLayout")
	uiGrid.CellSize = UDim2.fromOffset(96, 96)
	uiGrid.CellPadding = UDim2.fromOffset(8, 8)
	uiGrid.Parent = grid
end
ensureGridLayout()


local function makeCell(nameText, iconId, count)
	local f = Instance.new("Frame")
	f.BackgroundColor3 = Color3.fromRGB(28,28,32)
	f.BackgroundTransparency = 0.2

	local img = Instance.new("ImageLabel")
	img.BackgroundTransparency = 1
	img.Size = UDim2.fromScale(0.8, 0.7)
	img.AnchorPoint = Vector2.new(0.5, 0)
	img.Position = UDim2.fromScale(0.5, 0.12)
	img.Image = iconId or ""
	img.ImageTransparency = iconId and 0 or 0.2
	img.Parent = f

	local name = Instance.new("TextLabel")
	name.BackgroundTransparency = 1
	name.Text = nameText
	name.Font = Enum.Font.Gotham
	name.TextSize = 14
	name.TextColor3 = Color3.fromRGB(230,230,230)
	name.Size = UDim2.fromScale(1, 0.2)
	name.Position = UDim2.fromScale(0, 0.72)
	name.Parent = f

	local qty = Instance.new("TextLabel")
	qty.BackgroundTransparency = 1
	qty.Text = tostring(count or 0)
	qty.Font = Enum.Font.GothamBold
	qty.TextSize = 16
	qty.TextColor3 = Color3.fromRGB(255,210,100)
	qty.AnchorPoint = Vector2.new(1,1)
	qty.Position = UDim2.fromScale(0.98, 0.98)
	qty.Size = UDim2.fromOffset(40, 20)
	qty.Parent = f

	return f
end

local function rebuild()
	-- v1.0.2: 셀만 정리하고, 레이아웃은 보존/필요시 재생성
	for _, child in ipairs(grid:GetChildren()) do
		if not child:IsA("UIGridLayout") then
			child:Destroy()
		end
	end
	ensureGridLayout()


	local inv = lp:FindFirstChild("Inventory")
	local amounts = {}
	if inv then
		for _, v in ipairs(inv:GetChildren()) do
			if v:IsA("IntValue") then
				amounts[v.Name] = v.Value
			end
		end
	end

	-- ShopConfig.Items 순서대로 렌더
	for _, it in ipairs(ShopConfig.Items) do
		local id, name = it.id, it.name
		local icon = ItemIcons[id]
		local count = amounts[id] or 0
		local cell = makeCell(name, icon, count)
		cell.Parent = grid
	end
end

-- I 키 토글
UserInputService.InputBegan:Connect(function(inp, gp)
	if gp then return end
	if inp.KeyCode == Enum.KeyCode.Backquote then -- ` 키
		gui.Enabled = not gui.Enabled
		if gui.Enabled then rebuild() end
	end
end)

-- 인벤토리 변화 시 자동 갱신(열려 있을 때)
local function watchInv(inv)
	local function onChange()
		if gui.Enabled then rebuild() end
	end
	inv.ChildAdded:Connect(onChange)
	inv.ChildRemoved:Connect(onChange)
	for _, v in ipairs(inv:GetChildren()) do
		if v:IsA("IntValue") then
			v:GetPropertyChangedSignal("Value"):Connect(onChange)
		end
	end
end
local inv0 = lp:FindFirstChild("Inventory")
if inv0 then watchInv(inv0) else
	lp.ChildAdded:Connect(function(c)
		if c.Name == "Inventory" then watchInv(c) end
	end)
end
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBXBEA5969B93CA4EA69035DD99AF631F41">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">MoneyHUD</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{EFC4E117-5DE7-4A73-B8D3-135F420E12EE}</string>
				<ProtectedString name="Source"><![CDATA[-- Version 1.0
-- MoneyHUD: 우측하단에 플레이어 코인을 실시간 표시하는 UI
-- 초보 설명:
--  - Player Attribute(ShopConfig.CurrencyName)를 읽어 숫자를 보여줍니다.
--  - 값이 바뀌면 자동으로 갱신됩니다.

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

-- 경로 유연한 require
local function requireShared(name)
	local sharedFolder = ReplicatedStorage:FindFirstChild("Shared")
	if sharedFolder and sharedFolder:FindFirstChild(name) then
		return require(sharedFolder[name])
	end
	return require(ReplicatedStorage:WaitForChild(name))
end

local Config = requireShared("ShopConfig")
local lp = Players.LocalPlayer
local pg = lp:WaitForChild("PlayerGui")

-- ScreenGui
local gui = Instance.new("ScreenGui")
gui.Name = "MoneyHUD"
gui.IgnoreGuiInset = true
gui.ResetOnSpawn = false
gui.Parent = pg

-- 컨테이너
local frame = Instance.new("Frame")
frame.BackgroundColor3 = Color3.fromRGB(28,28,32)
frame.BackgroundTransparency = 0.2
frame.Size = UDim2.fromOffset(160, 46)
frame.AnchorPoint = Vector2.new(1,1)
frame.Position = UDim2.fromScale(0.98, 0.98)
frame.Parent = gui
frame.ZIndex = 40
local corner = Instance.new("UICorner"); corner.CornerRadius = UDim.new(0,10); corner.Parent = frame

-- 라벨
local title = Instance.new("TextLabel")
title.BackgroundTransparency = 1
title.Text = Config.CurrencyName or "Coins"
title.Font = Enum.Font.Gotham
title.TextSize = 14
title.TextColor3 = Color3.fromRGB(200, 255, 200)
title.Position = UDim2.fromOffset(10, 4)
title.Size = UDim2.fromOffset(140, 16)
title.Parent = frame
title.ZIndex = 41

local value = Instance.new("TextLabel")
value.BackgroundTransparency = 1
value.Text = "0"
value.Font = Enum.Font.GothamBold
value.TextSize = 24
value.TextColor3 = Color3.fromRGB(255, 230, 120)
value.TextXAlignment = Enum.TextXAlignment.Right
value.Position = UDim2.fromOffset(10, 18)
value.Size = UDim2.fromOffset(140, 24)
value.Parent = frame
value.ZIndex = 41

-- 갱신 함수
local function updateCoins()
	local n = lp:GetAttribute(Config.CurrencyName) or 0
	value.Text = tostring(n)
	-- 살짝 튀는 연출
	local t = TweenService:Create(frame, TweenInfo.new(0.08, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Size = UDim2.fromOffset(168, 50)})
	t:Play(); t.Completed:Wait()
	TweenService:Create(frame, TweenInfo.new(0.08), {Size = UDim2.fromOffset(160, 46)}):Play()
end

-- 초기값/리스너
lp:GetAttributeChangedSignal(Config.CurrencyName):Connect(updateCoins)
task.defer(updateCoins)
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>