<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="Script" referent="RBX1F31135BF70C4BD79C721D5ED245B246">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">GiveStarterTools</string>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{5D0B50A6-4D9F-4ED3-B0D3-A937DC735049}</string>
			<ProtectedString name="Source"><![CDATA[-- Version 1.1
--[[
  역할: 테스트 편의용으로 입장 시 TomatoSeed를 지급해서 바로 심어볼 수 있게 합니다.
  실제 게임에선 상점/인벤토리에서 지급하세요.
--]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

Players.PlayerAdded:Connect(function(plr)
	local toolsFolder = ReplicatedStorage:WaitForChild("Tools")
	local tpl = toolsFolder:FindFirstChild("TomatoSeed")
	if tpl and tpl:IsA("Tool") then
		local t = tpl:Clone()
		t.Parent = plr:WaitForChild("Backpack")
		-- 재입장 시 계속 들고 있게 StarterGear에도 복사(테스트용)
		local t2 = tpl:Clone()
		t2.Parent = plr:WaitForChild("StarterGear")
	end
	
	-- ★ CornSeed 지급(신규)
	local tplCorn = toolsFolder:FindFirstChild("CornSeed")
	if tplCorn and tplCorn:IsA("Tool") then
		tplCorn:Clone().Parent = plr:WaitForChild("Backpack")
		tplCorn:Clone().Parent = plr:WaitForChild("StarterGear")
	end
	
	-- ★ Axe 지급(벌목 테스트용)
	local tplAxe = toolsFolder:FindFirstChild("Axe")
	if tplAxe and tplAxe:IsA("Tool") then
		tplAxe:Clone().Parent = plr:WaitForChild("Backpack")
		tplAxe:Clone().Parent = plr:WaitForChild("StarterGear")
	end
end)
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Script" referent="RBX3837F504387E43798ADCED3B2B6FB58A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">HarvestService</string>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{215D00F3-D9F4-4781-8BE1-693A1E27EC8D}</string>
			<ProtectedString name="Source"><![CDATA[-- Version 1.1
--[[
  수확 처리 서버 스크립트
  - 클릭된 대상이 Plants 하위 작물인지 확인
  - 내 소유(OwnerUserId) + 수확가능(Stage==최종단계 or IsHarvestable=true) 검증
  - PlantConfig.Harvest 설정을 읽어 ItemService로 Backpack 지급/스택
  - 성공 시 해당 작물을 제거
--]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local HarvestRequest = Remotes:WaitForChild("HarvestRequest")

local PlantsFolder = workspace:WaitForChild("Plants")

local Plot = require(ServerScriptService:WaitForChild("PlotAssignmentHandler"))
local PlantConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("PlantConfig"))
local ItemService = require(ServerScriptService:WaitForChild("ItemService"))

-- 간단 쿨다운(스팸 방지)
local lastHarvestAt = {} -- [UserId] = tick()

local function findTopCropModel(inst)
	-- Plants 폴더 바로 아래의 Model까지 거슬러 올라감
	local m = inst and inst:FindFirstAncestorOfClass("Model")
	while m and m.Parent ~= PlantsFolder do
		m = m.Parent
		if not m or not m:IsA("Instance") then break end
	end
	if m and m.Parent == PlantsFolder then return m end
	return nil
end

--HarvestRequest.OnServerEvent:Connect(function(player, targetInstance)
--	-- 0) 간단 쿨다운
--	local now = tick()
--	if (lastHarvestAt[player.UserId] or 0) + 0.15 > now then return end
--	lastHarvestAt[player.UserId] = now

--	local cropModel = findTopCropModel(targetInstance)
--	if not cropModel then return end

--	-- 1) 소유 검사(작물 소유자 + 플롯 소유자 모두 확인)
--	local ownerId = cropModel:GetAttribute("OwnerUserId")
--	if ownerId ~= player.UserId then return end

--	local plotId = cropModel:GetAttribute("PlotId")
--	local plotsFolder = workspace:FindFirstChild("Plots")
--	local plotModel = plotsFolder and plotId and plotsFolder:FindFirstChild(plotId)
--	if not plotModel or not Plot.IsOwner(player, plotModel) then return end

--	-- 2) 수확 가능 여부
--	local cropType = cropModel:GetAttribute("CropType")
--	local stage = cropModel:GetAttribute("Stage") or 1
--	local isHarvestable = cropModel:GetAttribute("IsHarvestable") == true

--	local cfg = cropType and PlantConfig:GetCrop(cropType) or nil
--	if not cfg then return end
--	if not isHarvestable and stage < (cfg.Stages or 1) then
--		-- 아직 미성숙
--		return
--	end

--	-- 3) 지급 정보
--	local harvest = cfg.Harvest or {ToolName=cropType, Yield=1}
--	local toolName = harvest.ToolName or cropType
--	local yield = harvest.Yield or 1

--	-- 4) 지급
--	local ok = ItemService.GiveItem(player, toolName, yield)
--	if not ok then return end

--	-- 5) 작물 제거
--	cropModel:Destroy()
--end)


-- 공통 수확 처리
local function handleHarvest(player, cropModel)
	-- 1) 소유/플롯 검사
	local ownerId = cropModel:GetAttribute("OwnerUserId")
	if ownerId ~= player.UserId then return end

	local plotId = cropModel:GetAttribute("PlotId")
	local plotsFolder = workspace:FindFirstChild("Plots")
	local plotModel = plotsFolder and plotId and plotsFolder:FindFirstChild(plotId)
	if not plotModel or not Plot.IsOwner(player, plotModel) then return end

	-- 2) 수확 가능 여부
	local cropType = cropModel:GetAttribute("CropType")
	local stage = cropModel:GetAttribute("Stage") or 1
	local isHarvestable = cropModel:GetAttribute("IsHarvestable") == true

	local cfg = cropType and PlantConfig:GetCrop(cropType) or nil
	if not cfg then return end
	if not isHarvestable and stage < (cfg.Stages or 1) then return end

	-- 3) 지급
	local harvest = cfg.Harvest or {ToolName=cropType, Yield=1}
	local ok = ItemService.GiveItem(player, harvest.ToolName or cropType, harvest.Yield or 1)
	if not ok then return end

	-- 4) 제거
	cropModel:Destroy()
end

-- Version 1.3
--[[
  변경점:
   ▪ 클릭 수확(RemoteEvent) 비활성화
   ▪ 수확은 ProximityPrompt(E, HoldDuration)만 사용
--]]

-- 공통 수확 처리 (기존 그대로)
-- local function handleHarvest(player, cropModel) ... end

-- [삭제 대체] 클릭 수확은 더 이상 사용하지 않음
HarvestRequest.OnServerEvent:Connect(function(player, _)
	warn("[HarvestService v1.3] 클릭 수확은 비활성화되었습니다. E키 프롬프트를 사용하세요.")
end)

-- E 수확(ProximityPrompt) 그대로 유지
local function hookPrompt(pp)
	if not (pp and pp:IsA("ProximityPrompt") and pp.Name == "HarvestPrompt") then return end
	pp.Triggered:Connect(function(player)
		local cropModel = pp:FindFirstAncestorOfClass("Model")
		if cropModel and cropModel.Parent == PlantsFolder then
			handleHarvest(player, cropModel)
		end
	end)
end

for _, d in ipairs(PlantsFolder:GetDescendants()) do
	if d:IsA("ProximityPrompt") and d.Name == "HarvestPrompt" then
		hookPrompt(d)
	end
end
PlantsFolder.DescendantAdded:Connect(function(inst)
	if inst:IsA("ProximityPrompt") and inst.Name == "HarvestPrompt" then
		hookPrompt(inst)
	end
end)

]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Script" referent="RBX25C2C62DF16D4BB099D66D75C74736DB">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">PlantService</string>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{6DB6DE01-8AA0-410E-96EB-E25646CFF08E}</string>
			<ProtectedString name="Source"><![CDATA[-- Version 1.4.4

--[[
  역할: "심기 요청 처리 + 서버 검증 + 성장 단계 진행"
  왜 서버에 있나요?
   - 치트 방지: 내 밭인지, 자리 겹침 없는지, 유효 툴인지 등을 서버에서 검증해야 안전합니다.

  처리 흐름:
   1) 클라이언트가 PlantRequest(RemoteEvent)로 (툴이름, 클릭한 Part, 클릭 위치) 전송
   2) 서버에서 다음을 검증:
      ▪ 플레이어가 실제 TomatoSeed를 장착 중인지
      ▪ 클릭 대상이 Workspace/Plots의 내 밭 PrimaryPart(Base)인지
      ▪ 해당 위치에 다른 작물과 간격(FootprintRadius) 충돌 없는지
   3) 통과 시 Plants 폴더에 Crop(Model) 생성, Stage=1
   4) StageDuration에 맞춰 Stage를 2→3→4로 올림 (Stage4에 IsHarvestable=true)
--]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Players = game:GetService("Players")

local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local PlantRequest = Remotes:WaitForChild("PlantRequest")

local PlantsFolder = workspace:FindFirstChild("Plants") or Instance.new("Folder", workspace)
PlantsFolder.Name = "Plants"

-- 밭 권한 모듈 (v1.3)
local PlotModule = require(ServerScriptService:WaitForChild("PlotAssignmentHandler"))
local PlantConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("PlantConfig"))

-- 간단 유틸: 2D 평면 거리(XZ)
local function flatDist(a, b)
	local dx = a.X - b.X
	local dz = a.Z - b.Z
	return math.sqrt(dx*dx + dz*dz)
end

-- 바닥 스냅: 모델의 바운딩박스 하단을 targetCFrame의 Y에 정확히 맞춘다
local function placeModelOnSurface(model, targetCFrame, extraOffsetY)
	-- 1) 우선 목표 위치로 피벗 이동
	model:PivotTo(targetCFrame)

	-- 2) 현재 바운딩박스 기준으로 "바닥이 어디 있는지" 계산
	local bboxCf, bboxSize = model:GetBoundingBox()
	local currentBottomY = bboxCf.Position.Y - (bboxSize.Y / 2)

	-- 3) 목표 바닥 Y (HeightOffset을 더해 살짝 띄움)
	local desiredBottomY = targetCFrame.Position.Y + (extraOffsetY or 0)

	-- 4) 차이만큼 Y로 보정
	local deltaY = desiredBottomY - currentBottomY
	if math.abs(deltaY) > 1e-4 then
		model:PivotTo(model:GetPivot() * CFrame.new(0, deltaY, 0))
	end
end


-- 같은 Plot 위에 있는 기존 작물과 "간격" 충돌 검사
local function isSpotFree(plotId, pos, radius)
	for _, crop in ipairs(PlantsFolder:GetChildren()) do
		if crop:IsA("Model") and crop:GetAttribute("PlotId") == plotId then
			local cpos = crop:GetAttribute("WorldPos")
			if typeof(cpos) == "Vector3" then
				if flatDist(pos, cpos) < radius * 2 then
					return false
				end
			end
		end
	end
	return true
end

local function setStageVisual(cropModel, cropName, stageIndex)
	-- 시각 컨테이너 보장
	local visualFolder = cropModel:FindFirstChild("Visual") or Instance.new("Folder")
	visualFolder.Name = "Visual"
	visualFolder.Parent = cropModel
	-- 이전 비주얼 제거
	for _, ch in ipairs(visualFolder:GetChildren()) do ch:Destroy() end

	local cfg = PlantConfig:GetCrop(cropName)
	local provider = cfg and cfg.StageModels and cfg.StageModels[stageIndex]
	local prefab = provider and provider()

	-- 작물 루트 위치(월드 좌표)
	local targetCFrame
	if cropModel.PrimaryPart then
		targetCFrame = cropModel.PrimaryPart.CFrame
	else
		-- 혹시 몰라 WorldPos Attribute로도 백업
		local wp = cropModel:GetAttribute("WorldPos")
		targetCFrame = CFrame.new(typeof(wp) == "Vector3" and wp or Vector3.new())
	end

	if prefab and prefab:IsA("Model") then
		local cloned = prefab:Clone()
		cloned.Parent = visualFolder

		-- 1) 모든 파트 안전 설정(떨어짐/충돌 방지)
		for _, d in ipairs(cloned:GetDescendants()) do
			if d:IsA("BasePart") then
				d.Anchored = true
				d.CanCollide = false
			end
		end

		-- 2) PrimaryPart 자동 지정(없으면 Root/Base/첫 BasePart 순)
		if not cloned.PrimaryPart then
			local basePart = cloned:FindFirstChild("Root")
			if not (basePart and basePart:IsA("BasePart")) then
				basePart = cloned:FindFirstChild("Base")
			end
			if not (basePart and basePart:IsA("BasePart")) then
				for _, p in ipairs(cloned:GetDescendants()) do
					if p:IsA("BasePart") then
						basePart = p; break
					end
				end
			end
			if basePart then
				cloned.PrimaryPart = basePart
			end
		end

		-- PivotTo 후 바닥 스냅으로 미세 오프셋을 자동 보정
		placeModelOnSurface(cloned, targetCFrame, (cfg and cfg.HeightOffset) or 0)


	else
		-- 프리팹이 없을 때 임시 파트 생성(테스트용)
		local dummy = Instance.new("Part")
		dummy.Anchored = true
		dummy.CanCollide = false
		dummy.Name = "Stage"..stageIndex
		dummy.Size = Vector3.new(0.8 + stageIndex*0.2, 0.4 + stageIndex*0.2, 0.8 + stageIndex*0.2)
		dummy.CFrame = targetCFrame * CFrame.new(0, dummy.Size.Y/2, 0)
		dummy.Parent = visualFolder
	end
end

-- 수확 프롬프트(E) 보장 함수
-- ▪ 최종 단계에서만 생성
-- ▪ Owner만 눌러도 서버에서 검증하므로 안전
local function ensureHarvestPrompt(cropModel, cropName)
	local attachParent = cropModel.PrimaryPart or cropModel
	local old = attachParent:FindFirstChild("HarvestPrompt")
	if old and old:IsA("ProximityPrompt") then old:Destroy() end

	local cfg = PlantConfig:GetCrop(cropName)
	local hv  = cfg and cfg.Harvest or {}

	local prompt = Instance.new("ProximityPrompt")
	prompt.Name = "HarvestPrompt"
	prompt.ActionText = "수확"
	prompt.ObjectText = cropName
	prompt.KeyboardKeyCode = Enum.KeyCode.E
	prompt.GamepadKeyCode = Enum.KeyCode.ButtonX
	prompt.HoldDuration = hv.HoldDuration or 1.2       -- ★ 적용
	prompt.RequiresLineOfSight = false
	prompt.MaxActivationDistance = hv.MaxDistance or 12 -- ★ 적용
	prompt.Style = Enum.ProximityPromptStyle.Default
	prompt.Exclusivity = Enum.ProximityPromptExclusivity.OnePerButton
	-- ★ 클릭 비활성화: 프롬프트 UI 클릭으로는 트리거되지 않음 (E키/패드만)
	prompt.ClickablePrompt = false
	prompt.Parent = attachParent
end


-- 수확 프롬프트 제거(최종단계가 아닐 때)
local function removeHarvestPrompt(cropModel)
	local attachParent = cropModel.PrimaryPart or cropModel
	local p = attachParent:FindFirstChild("HarvestPrompt")
	if p and p:IsA("ProximityPrompt") then p:Destroy() end
end


--[v1.4+]
local function scheduleGrowth(cropModel, cropName)
	local cfg = PlantConfig:GetCrop(cropName)
	if not cfg then return end

	local stage = cropModel:GetAttribute("Stage") or 1
	-- 시각 업데이트
	setStageVisual(cropModel, cropName, stage)

	if stage >= cfg.Stages then
		-- 최종단계: 수확 가능 + E 프롬프트 생성
		cropModel:SetAttribute("IsHarvestable", true)
		ensureHarvestPrompt(cropModel, cropName)
		return
	end

	-- 최종단계가 아니라면 프롬프트 제거(혹시 남아있을 수도 있으니)
	removeHarvestPrompt(cropModel)

	-- 다음 단계 예약
	local delaySec = cfg.StageDuration[stage] or 10
	task.delay(delaySec, function()
		if cropModel and cropModel.Parent then
			cropModel:SetAttribute("Stage", stage + 1)
			scheduleGrowth(cropModel, cropName)
		end
	end)
end


-- 서버: 심기 요청 처리
PlantRequest.OnServerEvent:Connect(function(player, toolName, clickedPart, hitPos)
	-- 1) 기본 타입 체크 (toolName은 더 이상 신뢰하지 않음)
	if typeof(clickedPart) ~= "Instance" or typeof(hitPos) ~= "Vector3" then
		warn("[PlantService] 잘못된 인자")
		return
	end

	-- 2) 장착 툴 검증(이름 비교 제거)
	local char = player.Character
	local tool = char and char:FindFirstChildOfClass("Tool")
	if not tool then
		warn("[PlantService] 미장착")
		return
	end

	-- Seed 툴 여부: CropType StringValue가 있어야 함
	local cropTypeValue = tool:FindFirstChild("CropType")
	if not (cropTypeValue and cropTypeValue:IsA("StringValue")) then
		warn("[PlantService] 씨앗 툴 아님")
		return
	end

	-- 3) 작물 타입 확인 (툴 메타 우선, 대소문자 무시 + Seed 접미사 제거 폴백)
	local function normalizeCropName(s: string?): string?
		if typeof(s) ~= "string" or s == "" then return nil end
		-- 공백 트림 + 대소문자 정규화(첫 글자만 대문자, 나머지 소문자)
		s = s:gsub("^%s+", ""):gsub("%s+$", "")
		local lower = s:lower()
		-- "tomatoseed" → "tomato"
		if lower:sub(-4) == "seed" then
			lower = lower:sub(1, #lower-4)
		end
		-- 첫 글자 대문자화(PlantConfig가 "Tomato"/"Corn"처럼 TitleCase일 때 대응)
		return lower:sub(1,1):upper() .. lower:sub(2)
	end

	local cropName: string? = nil

	-- 3-1) Tool 내부 StringValue("CropType")를 우선 신뢰
	local cropTypeValue = tool:FindFirstChild("CropType")
	if cropTypeValue and cropTypeValue:IsA("StringValue") then
		cropName = normalizeCropName(cropTypeValue.Value)
	end

	-- 3-2) 폴백: Tool.Name이 TomatoSeed/CornSeed라면 Seed 제거해서 시도
	if (not cropName) or (not PlantConfig:GetCrop(cropName)) then
		cropName = normalizeCropName(tool.Name)
	end

	-- 최종 검증
	if not cropName or not PlantConfig:GetCrop(cropName) then
		warn("[PlantService] 알 수 없는 작물 타입: ", cropName)
		return
	end



	-- 4) 클릭 대상이 Workspace/Plots의 내 밭 PrimaryPart(Base)인지 확인
	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then
		warn("[PlantService] Plots 폴더 없음")
		return
	end

	local plotModel = clickedPart and clickedPart:FindFirstAncestorOfClass("Model")
	if not plotModel or plotModel.Parent ~= plotsFolder then
		warn("[PlantService] 클릭 대상이 Plots 하위가 아님")
		return
	end

	if plotModel.PrimaryPart ~= clickedPart then
		-- Base(PrimaryPart)를 클릭해야 심어지도록 강제 (간단/안전)
		warn("[PlantService] PrimaryPart가 아닌 곳 클릭됨 (Base를 클릭하세요)")
		return
	end

	-- 5) 내 밭인지 권한 확인
	if not PlotModule.IsOwner(player, plotModel) then
		warn("[PlantService] 소유자 아님: "..player.Name)
		return
	end

	-- 6) 심기 위치 보정(플롯의 로컬 좌표로 변환하여 표면에 정확히 스냅)
	local base = plotModel.PrimaryPart
	local cfg = PlantConfig:GetCrop(cropName)

	-- 6-1) 월드→로컬: 클릭 지점을 플롯 기준 좌표로 변환
	local localPoint = base.CFrame:PointToObjectSpace(hitPos)

	-- 6-2) 표면 Y(플롯 두께/2 + 약간의 띄움)로 고정
	local surfaceY = (base.Size.Y / 2) + (cfg.HeightOffset or 0.1)

	-- (선택) 가장자리 클램프 예시 — 필요 시 주석 해제
	-- local margin = cfg.FootprintRadius or 1
	-- local clampX = math.clamp(localPoint.X, -base.Size.X/2 + margin, base.Size.X/2 - margin)
	-- local clampZ = math.clamp(localPoint.Z, -base.Size.Z/2 + margin, base.Size.Z/2 - margin)
	-- localPoint = Vector3.new(clampX, localPoint.Y, clampZ)

	-- 6-3) 로컬→월드: 최종 월드 좌표 산출
	local pos = base.CFrame:PointToWorldSpace(Vector3.new(localPoint.X, surfaceY, localPoint.Z))


	-- 7) 기존 작물과 간격 충돌 체크
	local plotId = plotModel:GetAttribute("PlotId") or plotModel.Name
	if not isSpotFree(plotId, pos, cfg.FootprintRadius) then
		warn("[PlantService] 너무 가까워서 심을 수 없음")
		return
	end

	-- 8) 작물 모델 생성
	local cropModel = Instance.new("Model")
	cropModel.Name = cropName .. "_Crop"
	cropModel:SetAttribute("CropType", cropName)
	cropModel:SetAttribute("OwnerUserId", player.UserId)
	cropModel:SetAttribute("PlotId", plotId)
	cropModel:SetAttribute("Stage", 1)
	cropModel:SetAttribute("IsHarvestable", false)
	cropModel:SetAttribute("WorldPos", pos)

	-- 위치를 고정하기 위한 앵커 파트(루트 역할)
	local root = Instance.new("Part")
	root.Name = "Root"
	root.Anchored = true
	root.CanCollide = false
	root.Size = Vector3.new(0.2, 0.2, 0.2)
	root.CFrame = CFrame.new(pos)
	root.Parent = cropModel
	cropModel.PrimaryPart = root
	-- 시각/물리 노출을 완전히 끔
	root.Transparency = 1
	root.CastShadow = false
	root.CanQuery = false
	root.CanTouch = false


	cropModel.Parent = PlantsFolder

	-- 9) 비주얼 표시 및 성장 시작
	scheduleGrowth(cropModel, cropName)
end)
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Script" referent="RBXA688FB37506A47849CC9FD86FCC13F72">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">PlotAssignmentBootstrap</string>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{BFF41ACB-16E4-40D4-86EB-B8CDF05C8C29}</string>
			<ProtectedString name="Source"><![CDATA[-- Version 1.0
--[[
  역할: PlotAssignmentHandler(모듈)을 서버 시작 시점에 1회 초기화합니다.
  분리 이유: ModuleScript는 'require'될 때만 실행되므로, 서버 공통 초기화를 보장하기 위함입니다.
--]]

local ServerScriptService = game:GetService("ServerScriptService")
local Plot = require(ServerScriptService:WaitForChild("PlotAssignmentHandler"))
Plot.Init()  -- 한 번만 호출되며, 내부 가드로 중복 초기화 방지
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Script" referent="RBX514F00C4CAB54B949278503A5E459A08">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">RemotesBootstrap</string>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{80528220-3A20-470A-9A7E-279B1B70DCF2}</string>
			<ProtectedString name="Source"><![CDATA[-- Version 1.0
--[[
  서버 시작 시 Remotes를 보장 생성합니다.
  - ReplicatedStorage/Remotes (Folder)
  - RemoteEvent: PlantRequest, HarvestRequest
--]]
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local remotes = ReplicatedStorage:FindFirstChild("Remotes")
if not remotes then
	remotes = Instance.new("Folder")
	remotes.Name = "Remotes"
	remotes.Parent = ReplicatedStorage
end

local function ensureRemote(name)
	local r = remotes:FindFirstChild(name)
	if not r then
		r = Instance.new("RemoteEvent")
		r.Name = name
		r.Parent = remotes
	end
	return r
end

ensureRemote("PlantRequest")
ensureRemote("HarvestRequest")
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Script" referent="RBXB4B7ABB9D50749659D4FC084DF3A8432">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">ResourceService</string>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{F32932D7-A034-4B59-859B-16CEEBE4EB85}</string>
			<ProtectedString name="Source"><![CDATA[--Version v1.5.3

--[[
  🪓 ResourceService (벌목 서버 로직)
  목적: 나무(자원 노드)를 E키 프롬프트로 "여러 번" 타격해서 베고, 보상을 지급/리스폰한다.
  왜 서버에서 하나로 관리하나요?
   - 치트 방지: Axe 장착 여부/거리/중복 타격은 서버에서만 신뢰 가능
   - 동시 접속자들이 같은 나무를 치는 경우를 안정적으로 조정

  동작 요약:
   1) Workspace/Trees를 스캔 → 각 Tree Model에 NodeType/HP/MaxHP를 보장, ProximityPrompt 부착
   2) 플레이어가 E 누르면(홀드) → Axe 장착 검증 → HP -1 → 0이면 보상 지급 + 나무 숨김 + 리스폰 타이머
   3) RespawnSeconds 후 HP=MaxHP 복구, 프롬프트 재생성, 다시 벌목 가능
   
   --Version v1.5.3
   HP0로 쓰러져 보상 지급하는 구간에 인벤토리 반영 + 픽업 이벤트 송신을 정확히 추가.
--]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local ServerScriptService = game:GetService("ServerScriptService")
-- [추가] 체력 UI 모듈 로드

local TweenService = game:GetService("TweenService") -- ★ 모델 기울기/투명 애니용
-- ★ FX 모듈(흔들림/우수수 버스트)
local EffectLib = require(game.ReplicatedStorage:WaitForChild("Shared"):WaitForChild("FX"):WaitForChild("EffectLib"))
-- ★ Loot 픽업 알림용 RemoteEvent 보장
local remotes = ReplicatedStorage:FindFirstChild("Remotes") or Instance.new("Folder", ReplicatedStorage); remotes.Name = "Remotes"
local lootFolder = remotes:FindFirstChild("Loot") or Instance.new("Folder", remotes); lootFolder.Name = "Loot"
local evPicked = lootFolder:FindFirstChild("Picked") or Instance.new("RemoteEvent", lootFolder); evPicked.Name = "Picked"


-- Version 1.3.2 hotfix: forward declarations
-- (나중에 '함수 = function() end'로 대입해서 정의합니다)
local ensureChopPrompt
local setTreeGrowthVisual
--Version v1.3.7
local setTreeVisual          -- ★ Watcher에서 호출하므로 전방선언 추가
local removeChopPrompt       -- ★ 전방선언을 실제로 사용 (아래 정의도 local로 바꿈)


-- 필요시 removeChopPrompt도 전방 선언이 필요하다면 아래 주석 해제
-- local removeChopPrompt
local TreesFolder = workspace:WaitForChild("Trees")  -- ★ 나무 모음 폴더

local ResourceConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ResourceConfig"))
local ItemService = require(ServerScriptService:WaitForChild("ItemService"))

--디버그 작동
local DEBUG = true  -- 필요 없으면 false

local function dprint(...)
	if DEBUG then
		print("[ResourceService]", ...)
	end
end



--[[
  setModelVisible (v1.3.9)
  역할: 모델의 '겉모습'만 보이거나 숨김. Trunk(PrimaryPart)는 건드리지 않음.
  왜 이렇게? 성장 단계에서 Trunk가 다시 나타나 Grow1/2를 가리는 문제를 방지.
]]
-- Version v1.4.0: Visual 폴더 전용 보/숨 (Trunk는 절대 건드리지 않음)
local function setModelVisible(model, visible)
	-- Visual 폴더가 없으면 만들어 둔다 (안전)
	local visual = model:FindFirstChild("Visual")
	if not visual then
		visual = Instance.new("Folder")
		visual.Name = "Visual"
		visual.Parent = model
	end

	for _, d in ipairs(visual:GetDescendants()) do
		if d:IsA("BasePart") then
			d.Anchored = true
			d.CanCollide = false
			d.Transparency = visible and 0 or 1
		end
	end
end


--[[
  setTrunkHidden (v1.3.9)
  역할: Trunk(PrimaryPart)를 항상 숨김/표시 제어. 우리는 '항상 숨김'으로 사용.
  이유: 프롬프트/Pivot 전용으로 쓰고, 실제 외형은 Visual 프리팹이 그린다.
]]
local function setTrunkHidden(model, hidden)
	local trunk = model.PrimaryPart or model:FindFirstChild("Trunk")
	if trunk and trunk:IsA("BasePart") then
		trunk.Transparency = hidden and 1 or 0
		trunk.CanCollide = true  -- 기준 파트이므로 충돌은 켜 둠(원하면 false 가능)
	end
end


-- ★ Visual 폴더 하위 파츠를 '무조건' 보이게 강제 복구
--    (베기 애니/스트리밍/타이밍 이슈로 투명·충돌 설정이 남는 경우를 원천 차단)
local function forceVisualVisible(model)
	local visual = model:FindFirstChild("Visual")
	if not visual then return end
	for _, d in ipairs(visual:GetDescendants()) do
		if d:IsA("BasePart") then
			d.Anchored = true        -- 안전: 물리 영향 제거
			d.CanCollide = false     -- 성장 단계 오브젝트는 충돌 X
			d.Transparency = 0       -- ★ 항상 보이게
		end
	end
end

-- 인벤토리 보장
-- ★ Inventory(IntValue) 보장 유틸 - Shop 시스템과 호환
local function ensureInventory(player: Player)
	local folderName = "Inventory"
	local f = player:FindFirstChild(folderName)
	if not f then
		f = Instance.new("Folder")
		f.Name = folderName
		f.Parent = player
	end
	return f
end

local function ensureItem(inv: Folder, id: string)
	local v = inv:FindFirstChild(id)
	if not v then
		v = Instance.new("IntValue")
		v.Name = id
		v.Value = 0
		v.Parent = inv
	end
	return v
end



-- 프롬프트 생성/제거
removeChopPrompt = function(model)
	local attach = model.PrimaryPart or model
	local old = attach:FindFirstChild("ChopPrompt")
	if old and old:IsA("ProximityPrompt") then old:Destroy() end
end

-- Version 1.2 보강 함수들 ----------------------------

-- ★ 원래 트리의 시각 파츠 비우기(리스폰 전에 깨끗이)
local function clearTreeVisual(model)
	local visual = model:FindFirstChild("Visual")
	if visual then
		for _, ch in ipairs(visual:GetChildren()) do ch:Destroy() end
	end
end

-- ★ HP0에서 실행: 트렁크를 '바닥에서 회전'시키며 점점 투명하게
--    - player를 기준으로 '플레이어 반대 방향'으로 쓰러지게 처리(안전)
local function playFellAnimation(model, player, tweenSec)
	-- 1) 필수 파트 확보
	local trunk = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
	if not trunk then return end

	-- 2) 시작/목표 CFrame 계산(바닥 축을 중심으로 기울기)
	local startCF = trunk.CFrame
	local halfH = trunk.Size.Y / 2

	-- 플레이어 반대 방향으로 넘어지도록 방향 벡터 계산
	local fallDir = trunk.CFrame.LookVector -- 기본
	if player and player.Character and player.Character.PrimaryPart then
		local away = (trunk.Position - player.Character.PrimaryPart.Position)
		fallDir = Vector3.new(away.X, 0, away.Z)
		if fallDir.Magnitude < 1e-3 then
			fallDir = trunk.CFrame.LookVector
		else
			fallDir = fallDir.Unit
		end
	end

	-- 트렁크 위치에서 '넘어질 방향'으로 바라보게 하고, 바닥축에서 -70º 기울임
	local yaw = CFrame.new(startCF.Position, startCF.Position + fallDir)
	local tilt = CFrame.Angles(math.rad(-70), 0, 0)
	local targetCF = yaw * CFrame.new(0, -halfH, 0) * tilt * CFrame.new(0, halfH, 0)

	-- 3) 회전/투명 트윈 생성 후 실행(동시)
	local tinfo = TweenInfo.new(tweenSec or 0.65, Enum.EasingStyle.Cubic, Enum.EasingDirection.In)
	local rotTween = TweenService:Create(trunk, tinfo, { CFrame = targetCF })

	-- 모든 파츠 투명화(앵커/비충돌 보장)
	local parts = {}
	for _, d in ipairs(model:GetDescendants()) do
		if d:IsA("BasePart") then
			d.Anchored = true
			d.CanCollide = false
			table.insert(parts, d)
		end
	end
	for _, p in ipairs(parts) do
		TweenService:Create(p, TweenInfo.new(tweenSec or 0.65, Enum.EasingStyle.Quad, Enum.EasingDirection.In), { Transparency = 1 }):Play()
	end

	rotTween:Play()
	rotTween.Completed:Wait()

	-- 4) 숨기고, 트렁크 자세는 원복(리스폰 시 똑바로 나오게)
	setModelVisible(model, false)
	trunk.CFrame = startCF
	clearTreeVisual(model)
end
-- -----------------------------------------------------


-- ★ 원래 트리의 시각 파츠를 Visual 폴더로 격리하고 숨김
local function quarantineOriginalVisual(model)
	-- Visual 폴더 보장
	local visual = model:FindFirstChild("Visual")
	if not visual then
		visual = Instance.new("Folder")
		visual.Name = "Visual"
		visual.Parent = model
	end

	-- PrimaryPart(Trunk)와 ProximityPrompt를 제외한 자식들을 Visual로 이동
	for _, ch in ipairs(model:GetChildren()) do
		if ch ~= visual and ch ~= model.PrimaryPart and not ch:IsA("ProximityPrompt") then
			ch.Parent = visual
		end
	end

	-- 격리된 기존 파츠는 전부 숨김 + 비충돌 처리
	for _, d in ipairs(visual:GetDescendants()) do
		if d:IsA("BasePart") then
			d.Anchored = true
			d.CanCollide = false
			d.Transparency = 1
		end
	end
end


-- ★ 트리 외형 제거(Visual 폴더 정리)
local function removeTreeVisual(model)
	local visual = model:FindFirstChild("Visual")
	if visual then
		for _, ch in ipairs(visual:GetChildren()) do ch:Destroy() end
	else
		visual = Instance.new("Folder")
		visual.Name = "Visual"
		visual.Parent = model
	end
end

--[[
  v1.4.1 placeOnTrunk
  목적: 프리팹의 "진짜 바닥"을 트렁크 바닥 높이에 정확히 맞춘다.
  원리:
   1) 프리팹 Pivot 기준 로컬 좌표계로 각 BasePart의 '바닥 Y'(로컬Y - Size.Y/2)를 계산
   2) 그 중 최솟값이 모델의 "진짜 바닥 오프셋"(minBottom) → pivot이 중앙/상단/하단 어디든 보정 가능
   3) 트렁크 바닥 높이(트렁크 중심Y - 트렁크절반높이)에 -minBottom을 더해 최종 Y를 만든다
]]
function placeOnTrunk(prefabModel, trunkCF, trunkPart)
	-- 0) 물리 충돌/앵커 상태 정리 (겉모습이므로 고정)
	for _, d in ipairs(prefabModel:GetDescendants()) do
		if d:IsA("BasePart") then
			d.Anchored = true
			d.CanCollide = false
		end
	end

	-- 1) 트렁크의 회전(방향)만 미리 복사해 둘 오리엔테이션 행렬
	local orientation = (trunkCF - trunkCF.Position)

	-- 2) 프리팹의 Pivot 기준 '진짜 바닥 오프셋' 계산
	local pivotCF = prefabModel:GetPivot()
	local minBottom = math.huge
	for _, d in ipairs(prefabModel:GetDescendants()) do
		if d:IsA("BasePart") then
			-- 파츠의 'Pivot 로컬좌표'로 변환
			local localCF = pivotCF:ToObjectSpace(d.CFrame)
			-- 이 파츠의 바닥 Y (로컬)
			local bottomY = localCF.Position.Y - d.Size.Y/2
			if bottomY < minBottom then
				minBottom = bottomY
			end
		end
	end
	if minBottom == math.huge then
		minBottom = 0 -- 파츠가 없으면 0 보정
	end

	-- 3) 트렁크 바닥 높이(= 트렁크 중심Y - 절반높이)
	local trunkHalf = 0
	if trunkPart and trunkPart:IsA("BasePart") then
		trunkHalf = trunkPart.Size.Y / 2
	end
	local trunkBottomY = trunkCF.Position.Y - trunkHalf

	-- 4) 최종 배치 위치 = (트렁크 XZ, 바닥Y + '바닥 오프셋 보정')
	local targetPos = Vector3.new(
		trunkCF.Position.X,
		trunkBottomY - minBottom, -- minBottom은 보통 음수 → -minBottom 만큼 올림
		trunkCF.Position.Z
	)

	-- 5) 트렁크의 회전은 유지하고, 위치만 targetPos로
	local targetCF = CFrame.new(targetPos) * orientation
	prefabModel:PivotTo(targetCF)
end

--[[
  playHPChangeFX
  역할: HP 전환(HP3->HP2, HP2->HP1 등) 직후, 새 외형(root)에 흔들림과 파티클 버스트를 재생.
  왜 이렇게?  베기 타격감을 명확히 전달하고, 외형 전환과 동시에 자연스러운 피드백 제공.
]]
local function playHPChangeFX(model: Model, newRoot: Instance, prevHP: number, newHP: number)
	-- 1) 흔들림(작게)
	task.spawn(function()
		-- 잔렉 방지: 비동기로
		EffectLib.ShakeInstance(newRoot, math.rad(10), 0.14)
	end)

	-- 2) 파편/잎 버스트: 트렁크 위치에서 방출
	local trunkCF = (model.PrimaryPart and model.PrimaryPart.CFrame) or model:GetPivot()
	-- HP가 낮을수록(마지막 일격) 조금 더 많게
	local base = 60
	local add  = (prevHP == 2 and newHP == 1) and 30 or 15
	EffectLib.EmitBurstAt(trunkCF * CFrame.new(0, 1.8, 0), nil, base + add)
end



-- ★ 현재 HP에 맞는 외형으로 갱신
local function setTreeVisual(model, cfg)
	
	local hp = model:GetAttribute("HP") or (cfg.MaxHP or 3)
	removeTreeVisual(model)

	-- 프리팹 제공자 함수 찾기(없으면 nil)
	local provider = cfg.VisualModels and cfg.VisualModels[hp]
	local prefab = provider and provider()

	local visual = model:FindFirstChild("Visual")
	if not visual then
		visual = Instance.new("Folder")
		visual.Name = "Visual"
		visual.Parent = model
	end

	if prefab and prefab:IsA("Model") then
		local cloned = prefab:Clone()
		cloned.Parent = visual
		placeOnTrunk(cloned, (model.PrimaryPart and model.PrimaryPart.CFrame) or model:GetPivot(), model.PrimaryPart)

	else
		-- 프리팹이 없을 때 임시 시각(HP에 따른 크기/색) 생성
		local p = Instance.new("Part")
		p.Name = "TreeHP"..hp
		p.Anchored = true
		p.CanCollide = false
		p.Size = Vector3.new(2 + hp*0.2, 6 + hp*0.5, 2 + hp*0.2)
		p.Color = Color3.fromHSV((0.35 + hp*0.1)%1, 0.5, 0.9)
		p.Parent = visual

		-- ★ 바닥 정확 정렬(트렁크 바닥 = cf.Y - trunkHalf)
		local trunk = model.PrimaryPart
		local cf = trunk and trunk.CFrame or model:GetPivot()
		local trunkHalf = (trunk and trunk:IsA("BasePart")) and (trunk.Size.Y/2) or 0
		local trunkBottomY = cf.Position.Y - trunkHalf
		-- 임시 파트의 바닥 오프셋은 p.Size.Y/2 (Pivot가 중앙)
		local targetPos = Vector3.new(cf.Position.X, trunkBottomY + (p.Size.Y/2), cf.Position.Z)
		local orientation = (cf - cf.Position)
		p.CFrame = CFrame.new(targetPos) * orientation
	end
	
	-- ★ 이전에 그려둔 HP와 비교해서 FX 재생
	local prevShown = model:GetAttribute("LastHPVisual") or -1
	local newRoot = nil
	-- Visual 폴더에서 이번에 배치된 최상위 객체를 찾아본다(모델 또는 파트)
	do
		local visual = model:FindFirstChild("Visual")
		if visual then
			newRoot = visual:FindFirstChildWhichIsA("Model") or visual:FindFirstChildWhichIsA("BasePart")
		end
	end
	if newRoot and prevShown ~= -1 and prevShown ~= hp then
		-- HP가 실제로 바뀐 순간에만 FX
		playHPChangeFX(model, newRoot, prevShown, hp)
	end

	-- ★ 이번에 그린 HP를 저장(다음 비교용)
	model:SetAttribute("LastHPVisual", hp)
	
	-- ★ 어떤 경로(프리팹/임시)든 시각은 반드시 보이게 + Trunk는 숨김
	forceVisualVisible(model)
	setTrunkHidden(model, true)

end

-- Version 1.3.4: Mature 상태에서만 HP 비주얼을 적용하는 가드
local function setTreeVisualIfMature(model, cfg)
	if model:GetAttribute("TreeState") == "Mature" then
		setTreeVisual(model, cfg)
	end
end


-- ★ 성장 단계 외형 표시: GrowthModels[stage] 프리팹을 트렁크 위치에 배치
--    ▪ stage = 1..cfg.Growth.Stages
--    ▪ 성목(마지막 단계)는 HP3과 동일 비주얼을 쓰며, 이땐 chop 허용으로 전환한다.
-- Version 1.3.2: assign-form definition
setTreeGrowthVisual = function(model, cfg, stage)
	removeTreeVisual(model)

	local grow = cfg.Growth or {}
	local provider = grow.GrowthModels and grow.GrowthModels[stage]
	local prefab = provider and provider()

	local visual = model:FindFirstChild("Visual")
	if not visual then
		visual = Instance.new("Folder"); visual.Name="Visual"; visual.Parent=model
	end

	if prefab and prefab:IsA("Model") then
		local cloned = prefab:Clone(); cloned.Parent = visual
		placeOnTrunk(cloned, (model.PrimaryPart and model.PrimaryPart.CFrame) or model:GetPivot(), model.PrimaryPart)

	else
		-- 프리팹 없을 때 임시 시각(단계별 크기/색)
		local p = Instance.new("Part")
		p.Name = "GrowStage"..tostring(stage)
		p.Anchored = true; p.CanCollide = false
		p.Size = Vector3.new(1.5+stage*0.5, 3+stage*1.0, 1.5+stage*0.5)
		p.Color = Color3.fromRGB(170, 220 - stage*20, 170)
		p.Parent = visual
		local trunk = model.PrimaryPart
		local cf = trunk and trunk.CFrame or model:GetPivot()
		local trunkHalf = (trunk and trunk:IsA("BasePart")) and (trunk.Size.Y/2) or 0
		local trunkBottomY = cf.Position.Y - trunkHalf
		-- 임시 파트의 '바닥 오프셋'은 -p.Size.Y/2 (Pivot가 중앙이므로)
		local targetPos = Vector3.new(cf.Position.X, trunkBottomY + (p.Size.Y/2), cf.Position.Z)
		local orientation = (cf - cf.Position)
		p.CFrame = CFrame.new(targetPos) * orientation

	end
	
	-- (옵션) 성장 단계 전환 시에도 잎/파편 버스트
	do
		local trunkCF = (model.PrimaryPart and model.PrimaryPart.CFrame) or model:GetPivot()
		EffectLib.EmitBurstAt(trunkCF * CFrame.new(0, 1.0, 0), nil, 10)
	end
	
	-- ★ 어떤 경로로 생성됐든, 단계 표시가 끝나면 '무조건' 보이게 고정
	forceVisualVisible(model)
end

-- ★ 성장 시작/진행: TreeState="Growing", GrowthStage=1..N
local function startGrowthCycle(model, cfg)
	local grow = cfg.Growth
	if not grow or not grow.Stages or grow.Stages < 1 then
		model:SetAttribute("TreeState", "Mature")
		model:SetAttribute("HP", cfg.MaxHP)
		model:SetAttribute("IsFelled", false)
		setTreeVisual(model, cfg)
		ensureChopPrompt(model, cfg)
		return
	end

	model:SetAttribute("TreeState", "Growing")
	model:SetAttribute("GrowthStage", 1)
	setModelVisible(model, true)                 -- ★ 항상 보이게
	setTreeGrowthVisual(model, cfg, 1)
	removeChopPrompt(model)                      -- 성장 중 베기 금지
	-- ★ 성장 초기: Trunk는 절대 보이지 않게
	setTrunkHidden(model, true)	

	local function advance(stage)
		if not model or not model.Parent then return end
		local maxStage = grow.Stages
		if stage >= maxStage then
			--★성목 도달 분기
			model:SetAttribute("TreeState", "Mature")
			model:SetAttribute("GrowthStage", maxStage)
			model:SetAttribute("MaxHP", cfg.MaxHP or 3)   -- ★ UI용 최대체력 보장
			model:SetAttribute("HP", cfg.MaxHP or 3)
			setModelVisible(model, true)
			setTreeVisual(model, cfg)
			ensureChopPrompt(model, cfg)

			return
		end


		local delaySec = grow.StageDuration and grow.StageDuration[stage] or 20
		task.delay(delaySec, function()
			if not model or not model.Parent then return end
			local current = (model:GetAttribute("GrowthStage") or 1)
			if current ~= stage then return end

			local nextStage = stage + 1
			model:SetAttribute("GrowthStage", stage+1)

			setModelVisible(model, true)         -- ★ 단계 전환 때마다 가시화 보장
			-- ★ Trunk는 항상 숨김(가림 방지)
			setTrunkHidden(model, true)
			setTreeGrowthVisual(model, cfg, stage+1)

			print(("[ResourceService v1.4.2] %s Growth %d -> %d")
				:format(model.Name, stage, stage+1))

			advance(nextStage)
		end)
	end

	advance(1)
end



ensureChopPrompt = function(model, cfg)
	removeChopPrompt(model)
	local attach = model.PrimaryPart or model

	local pp = Instance.new("ProximityPrompt")
	pp.Name = "ChopPrompt"
	pp.ActionText = "벌목"
	pp.ObjectText = "나무"
	pp.KeyboardKeyCode = Enum.KeyCode.E
	pp.GamepadKeyCode = Enum.KeyCode.ButtonX
	pp.HoldDuration = cfg.HitHold or 0.8
	pp.MaxActivationDistance = cfg.MaxDistance or 12
	pp.RequiresLineOfSight = false
	pp.Style = Enum.ProximityPromptStyle.Default
	pp.Exclusivity = Enum.ProximityPromptExclusivity.OnePerButton
	pp.ClickablePrompt = false   -- ✅ E키 전용 (클릭/터치 비활성)
	pp.Parent = attach

	-- 트리거 연결
	pp.Triggered:Connect(function(player)
		-- 1) 툴 검증: Axe 장착 중?
		local char = player.Character
		local tool = char and char:FindFirstChildOfClass("Tool")
		local requireName = cfg.RequireToolName or "Axe"
		if not tool or tool.Name ~= requireName then
			-- (선택) 나중에 UI로 "도끼 필요" 안내 가능
			return
		end
		
		if model:GetAttribute("TreeState") == "Growing" then return end

		-- 2) 이미 베어진 나무면 무시
		if model:GetAttribute("IsFelled") then return end

		-- 3) HP 차감
		local hp = model:GetAttribute("HP") or cfg.MaxHP
		hp -= 1
		if hp < 0 then hp = 0 end
		model:SetAttribute("HP", hp)
		
		-- ★ 타격 직후 외형 갱신 (HP3→HP2→HP1)
		if hp > 0 then
			setTreeVisualIfMature(model, cfg)
		end

		-- Version 1.3.3
		-- 베어짐 처리 (애니 + 성장 전환)
		if hp <= 0 then
			model:SetAttribute("IsFelled", true)
			model:SetAttribute("TreeState", "Felled")  -- ★ 베어진 즉시 상태 고정
			removeChopPrompt(model)

			local reward = cfg.Reward or { ToolName = "Wood", Amount = 1 }
			ItemService.GiveItem(player, reward.ToolName or "Wood", reward.Amount or 1)
			
			---- ★ Wood 인벤토리 지급 + 픽업 알림(클라 HUD)
			--local rewardWood = (cfg and cfg.Reward and cfg.Reward.Wood) or 1  -- 기본 1
			--local inv = ensureInventory(player)
			--local wood = ensureItem(inv, "Wood")
			--wood.Value += rewardWood
			
			-- ★ 픽업 토스트(클라 HUD) 전송: 아이콘 + "+수량"
			evPicked:FireClient(player, {
				id  = reward.ToolName or "Wood",
				qty = reward.Amount or 1
			})

			playFellAnimation(model, player, 0.65)

			-- ★ 쓰러진 뒤 Grow1로 전환까지의 대기시간: StumpSeconds 우선, 없으면 RespawnSeconds
			local delayToGrow = (cfg.StumpSeconds ~= nil) and cfg.StumpSeconds or (cfg.RespawnSeconds or 0)

			task.delay(delayToGrow, function()
				if not model or not model.Parent then return end
				model:SetAttribute("IsFelled", false)   -- 성장 시작 전 상태 플래그 해제
				-- ✅ 성장 사이클 시작: Grow1 표시 + 타이머 예약(Grow2→성목)까지 자동 수행
				startGrowthCycle(model, cfg)
			end)


		end


	end)
end

-- ★ 성장/상태 변경 감시: 표시가 어긋나면 즉시 재도색/프롬프트 복구
local function attachGrowthWatchers(model, cfg)
	-- GrowthStage가 변하면 해당 단계 외형으로 재적용
	model:GetAttributeChangedSignal("GrowthStage"):Connect(function()
		if model:GetAttribute("TreeState") == "Growing" then
			local stage = model:GetAttribute("GrowthStage") or 1
			setModelVisible(model, true)                 -- 혹시 남은 투명 복구
			setTreeGrowthVisual(model, cfg, stage)
		end
	end)

	-- TreeState가 변하면 상태에 맞춰 복구
	model:GetAttributeChangedSignal("TreeState"):Connect(function()
		local state = model:GetAttribute("TreeState")
		if state == "Mature" then
			setModelVisible(model, true)
			setTreeVisual(model, cfg)
			setTrunkHidden(model, true)       -- ★ 항상 숨김 유지
			ensureChopPrompt(model, cfg)
		elseif state == "Growing" then
			removeChopPrompt(model)
			local stage = model:GetAttribute("GrowthStage") or 1
			setModelVisible(model, true)
			setTreeGrowthVisual(model, cfg, stage)
			setTrunkHidden(model, true)       -- ★ 항상 숨김 유지
		end
	end)
end



-- 나무 초기화 (Attribute/HP 보장 + 프롬프트 부착)
local function initTree(model)
	local nodeType = model:GetAttribute("NodeType") or "Tree"
	model:SetAttribute("NodeType", nodeType)
	local cfg = ResourceConfig:GetNode(nodeType)
	if not cfg then
		warn(("[ResourceService v1.1a] 미지원 NodeType: %s (%s)"):format(tostring(nodeType), model.Name))
		return
	end
	if not model.PrimaryPart then
		warn(("[ResourceService v1.1a] PrimaryPart(Trunk) 미지정: %s"):format(model.Name))
		return
	end

	local maxHp = cfg.MaxHP or 3
	if model:GetAttribute("MaxHP") == nil then model:SetAttribute("MaxHP", maxHp) end
	if model:GetAttribute("HP") == nil then model:SetAttribute("HP", maxHp) end
	if model:GetAttribute("IsFelled") == nil then model:SetAttribute("IsFelled", false) end

	-- ★ 1) 원래 트리 시각 파츠 격리/숨김
	quarantineOriginalVisual(model)
	-- Visual 폴더 존재 보장(없으면 생성)
	if not model:FindFirstChild("Visual") then
		local v = Instance.new("Folder")
		v.Name = "Visual"
		v.Parent = model
	end
	-- 기준 파트는 숨김 유지(겉모습은 Visual만 담당)
	setTrunkHidden(model, true)

	-- ★ Trunk는 항상 숨김(Visual이 외형 담당)
	setTrunkHidden(model, true)
	
	-- ★ 1.5) 성장/상태 감시 Watcher 부착 (언제든 즉시 복구)
	attachGrowthWatchers(model, cfg)

	-- ★ 2) 상태에 따라 복구
	local state = model:GetAttribute("TreeState")
	if state == "Growing" then
		-- 성장 중인 경우: 저장된 단계로 외형 복구 + 스케줄 이어서 진행
		local stage = model:GetAttribute("GrowthStage") or 1
		setModelVisible(model, true)
		setTreeGrowthVisual(model, cfg, stage)
		removeChopPrompt(model)
		-- 이어서 성장
		local grow = cfg.Growth
		if grow and stage < (grow.Stages or 1) then
			-- 간단: 현재 단계부터 다시 스케줄
			task.defer(function()
				startGrowthCycle(model, cfg)
			end)
		end
	else
		-- 기본: 성목 상태(베기 허용)
		model:SetAttribute("TreeState", "Mature")
		model:SetAttribute("HP", model:GetAttribute("HP") or (cfg.MaxHP or 3))
		setTreeVisual(model, cfg)
		ensureChopPrompt(model, cfg)
	end
end


-- 서버 시작 시 Trees 폴더 스캔
for _, m in ipairs(TreesFolder:GetChildren()) do
	if m:IsA("Model") then
		initTree(m)
	end
end
-- 이후 추가되는 나무도 지원
TreesFolder.ChildAdded:Connect(function(m)
	if m:IsA("Model") then
		-- PrimaryPart 세팅이 느리게 될 수 있으니 약간 대기
		task.defer(function()
			if not m.PrimaryPart then m:GetPropertyChangedSignal("PrimaryPart"):Wait() end
			initTree(m)
		end)
	end
end)
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Script" referent="RBXC98ACCF7D4444857BE12119689DC9F6F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">ShopService</string>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{D30B2735-31C7-4757-B5EE-9A52E22062B9}</string>
			<ProtectedString name="Source"><![CDATA[-- Version v1.2
-- ShopService: 상점 서버 로직 (검증/코인 증감/인벤토리 증감)
-- 안전설명:
-- - RemoteFunction(Buy/Sell)으로만 거래. 서버가 '최종 검증'을 수행합니다.
-- - 인벤토리는 Player.Inventory(IntValue들)로 간단 저장. 기존에 있으면 재사용.

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players           = game:GetService("Players")

local Config = require(ReplicatedStorage.Shared.ShopConfig)

-- ★ Remotes/Shop 폴더 보장
local remotes = ReplicatedStorage:FindFirstChild("Remotes") or Instance.new("Folder", ReplicatedStorage)
remotes.Name = "Remotes"
local shopFolder = remotes:FindFirstChild("Shop") or Instance.new("Folder", remotes)
shopFolder.Name = "Shop"
-- RemoteEvent로 일원화 (클라 :FireServer() 설계와 일치)
local evBuy  = shopFolder:FindFirstChild("Buy")
if not evBuy then
	evBuy = Instance.new("RemoteEvent")
	evBuy.Name = "Buy"
	evBuy.Parent = shopFolder
end

local evSell = shopFolder:FindFirstChild("Sell")
if not evSell then
	evSell = Instance.new("RemoteEvent")
	evSell.Name = "Sell"
	evSell.Parent = shopFolder
end


-- 폴더명은 Config.InventoryFolderName가 있으면 그걸 따르고, 없으면 "Inventory"
local function ensureInventory(plr: Player): Folder
	local name = (Config and Config.InventoryFolderName) or "Inventory"
	local f = plr:FindFirstChild(name)
	if not f then
		f = Instance.new("Folder")
		f.Name = name
		f.Parent = plr
	end
	return f
end


local function ensureItem(inv: Folder, id: string): IntValue
	local v = inv:FindFirstChild(id)
	if not v then
		v = Instance.new("IntValue")
		v.Name = id
		v.Value = 0
		v.Parent = inv
	end
	return v
end


-- 위 ensure* 를 단일 진입점으로 사용 (이중 생성 방지)
local function getInventory(player: Player)
	return ensureInventory(player)
end

local function getItemValue(inv: Folder, id: string)
	return ensureItem(inv, id)
end


local function findItem(id)
	for _, it in ipairs(Config.Items) do
		if it.id == id then return it end
	end
	return nil
end

-- 플레이어 코인 보장
local function ensureCoinsAttr(plr: Player)
	if plr:GetAttribute(Config.CurrencyName) == nil then
		plr:SetAttribute(Config.CurrencyName, 100) -- 시작 코인 0 (필요시 바꾸세요)
	end
end

Players.PlayerAdded:Connect(function(plr)
	ensureCoinsAttr(plr)
	-- v1.2: 인벤토리 폴더만 보장(항목은 구매/판매 시 자동 생성)
	ensureInventory(plr)
	getInventory(plr) -- 폴더만 보장
end)

-- 공통 응답형식
local function ok(tbl) tbl.ok = true; return tbl end
local function fail(msg) return { ok=false, error=msg } end

-- 구매 처리
-- RemoteEvent는 반환값이 없으므로 Connect 사용
evBuy.OnServerEvent:Connect(function(plr: Player, id: string, qty: number?)
	ensureCoinsAttr(plr)
	qty = math.clamp(tonumber(qty) or 1, 1, 999)

	local def = findItem(id)
	if not def or not def.buy then
		return -- 구매 불가 품목
	end

	local price = def.buy * qty
	local coins = plr:GetAttribute(Config.CurrencyName) or 0
	if coins < price then
		return -- 코인 부족
	end

	-- 인벤토리 증가: 정확히 qty만큼 딱 1회 증가
	local inv = ensureInventory(plr)
	local counter = ensureItem(inv, id)
	counter.Value += qty

	-- 코인 차감
	plr:SetAttribute(Config.CurrencyName, coins - price)
end)


-- 판매 처리
evSell.OnServerEvent:Connect(function(plr: Player, id: string, qty: number?)
	ensureCoinsAttr(plr)
	qty = math.clamp(tonumber(qty) or 1, 1, 999)

	local def = findItem(id)
	if not def or not def.sell then
		return -- 판매 불가 품목
	end

	local inv = getInventory(plr)
	local v = getItemValue(inv, id)
	if v.Value < qty then
		return -- 수량 부족
	end

	v.Value -= qty
	local coins = (plr:GetAttribute(Config.CurrencyName) or 0) + (def.sell * qty)
	plr:SetAttribute(Config.CurrencyName, coins)
end)

]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ModuleScript" referent="RBX0CBB45D6CDFF4544BD5C891A69DBE923">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">ItemService</string>
			<string name="ScriptGuid">{6F622B50-9626-4876-8353-267D327DE7E6}</string>
			<ProtectedString name="Source"><![CDATA[-- Version 1.1
--[[
  ItemService: 수확/보상 등으로 "툴"을 플레이어에게 지급하고, 같은 아이템이면 Backpack에서 스택합니다.
  ▪ ReplicatedStorage/Tools/Produce/<ToolName> 템플릿을 우선 찾음
  ▪ 없으면 ReplicatedStorage/Tools/<ToolName>에서도 시도
  ▪ 그래도 없으면 RequiresHandle=false 빈 툴을 즉석 생성(안전장치)
--]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local ItemService = {}

local function findTemplate(toolName)
	local tools = ReplicatedStorage:FindFirstChild("Tools")
	if not tools then return nil end
	local produce = tools:FindFirstChild("Produce")
	if produce then
		local t = produce:FindFirstChild(toolName)
		if t and t:IsA("Tool") then return t end
	end
	local t2 = tools:FindFirstChild(toolName)
	if t2 and t2:IsA("Tool") then return t2 end
	return nil
end

local function ensureMeta(tool, canonicalId)
	local amount = tool:FindFirstChild("Amount")
	if not amount then
		amount = Instance.new("IntValue")
		amount.Name = "Amount"
		amount.Value = 1
		amount.Parent = tool
	end
	local itemId = tool:FindFirstChild("ItemId")
	if not itemId then
		itemId = Instance.new("StringValue")
		itemId.Name = "ItemId"
		itemId.Value = canonicalId or tool.Name
		itemId.Parent = tool
	else
		if canonicalId and itemId.Value ~= canonicalId then
			itemId.Value = canonicalId
		end
	end
end

-- 같은 아이템 판단(이름이 'Tomato xN'이어도 true)
local function isSameItem(tool, toolName)
	local id = tool:FindFirstChild("ItemId")
	if id and id:IsA("StringValue") and id.Value == toolName then
		return true
	end
	if tool.Name == toolName then return true end
	if string.match(tool.Name, "^" .. toolName .. " x%d+$") then
		return true
	end
	return false
end

-- Backpack + Character에서 모두 수집
local function collectPlayerTools(player)
	local list = {}
	local bp = player:FindFirstChild("Backpack")
	if bp then
		for _, t in ipairs(bp:GetChildren()) do
			if t:IsA("Tool") then table.insert(list, t) end
		end
	end
	local char = player.Character
	if char then
		for _, t in ipairs(char:GetChildren()) do
			if t:IsA("Tool") then table.insert(list, t) end
		end
	end
	return list
end

-- 중복 병합: target 하나를 정하고 같은 아이템들을 모두 합침
local function mergeAllInto(target, others, toolName)
	ensureMeta(target, toolName)
	local total = target.Amount.Value
	for _, t in ipairs(others) do
		if t ~= target and isSameItem(t, toolName) then
			ensureMeta(t, toolName)
			total += (t.Amount and t.Amount.Value or 1)
			t:Destroy()
		end
	end
	target.Amount.Value = total
	target.Name = ("%s x%d"):format(toolName, total)
	return target
end

function ItemService.GiveItem(player, toolName, addAmount)
	addAmount = tonumber(addAmount) or 1

	-- 1) 내 모든 툴 수집(Backpack + Character)
	local all = collectPlayerTools(player)

	-- 2) 같은 아이템 목록 필터
	local same = {}
	for _, t in ipairs(all) do
		if isSameItem(t, toolName) then
			table.insert(same, t)
		end
	end

	-- 3) 타겟 결정: 캐릭터에 들고 있는게 있으면 그걸 우선, 없으면 아무거나
	local target = nil
	for _, t in ipairs(same) do
		if t.Parent == (player.Character or t.Parent) then
			target = t; break
		end
	end
	if not target then target = same[1] end

	-- 4) 존재하면 병합 + 수량 증가
	if target then
		target = mergeAllInto(target, same, toolName)
		target.Amount.Value += addAmount
		target.Name = ("%s x%d"):format(toolName, target.Amount.Value)
		return true, "Stacked"
	end

	-- 5) 아예 없으면 새로 지급(Backpack에)
	local backpack = player:FindFirstChild("Backpack")
	if not backpack then return false, "NoBackpack" end

	local tpl = findTemplate(toolName)
	local tool
	if tpl then
		tool = tpl:Clone()
	else
		tool = Instance.new("Tool")
		tool.Name = toolName
		tool.RequiresHandle = false
	end
	tool.Parent = backpack

	ensureMeta(tool, toolName)
	tool.Amount.Value = addAmount
	tool.Name = ("%s x%d"):format(toolName, tool.Amount.Value)

	return true, "Granted"
end

return ItemService]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ModuleScript" referent="RBXF9AA36BE65B44CFF9B7B7358DD70A319">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">PlotAssignmentHandler</string>
			<string name="ScriptGuid">{CC351A56-05F0-4E6B-BE99-A7A79DA1ECDF}</string>
			<ProtectedString name="Source"><![CDATA[-- Version 1.4a
--[[
  모듈 역할(초보자 친절 설명):
  - "밭 배정/해제/소유권 확인"을 담당하는 **서버 전용 모듈**입니다.
  - v1.4a에서는 Script가 아니라 **ModuleScript**로 변경되어
    다른 서버 스크립트(예: PlantService)가 require로 안전하게 사용할 수 있습니다.

  동작 개요:
  1) Init()에서 Workspace/Plots를 스캔 → PlotId 표준화 → 정렬(plotOrder: Plot1→Plot2→…)
  2) PlayerAdded/Removing 연결, 빈 밭(false) → 소유자(UserId)로 업데이트
  3) IsOwner(player, plotModel)로 소유권 검사 제공 (심기/수확 등에서 호출)

  용어 정리:
  - PrimaryPart: Model의 대표 파트(보통 Base). 반드시 지정!
  - Attribute: 객체에 다는 데이터 라벨. 여기서는 "PlotId" 문자열 사용.

  사용법:
  - 다른 스크립트에서 `local Plot = require(ServerScriptService.PlotAssignmentHandler)`
  - 서버 시작 시 `Plot.Init()`를 한 번 호출(부트스크립트가 호출)
  - 소유권 검사: `Plot.IsOwner(player, plotModel)`
--]]

local Players = game:GetService("Players")
local PlotsFolder = workspace:WaitForChild("Plots")

-- 내부 상태
local assignedPlots = {}   -- [PlotId] = false(빈 밭) 또는 UserId(소유자)
local playerPlots   = {}   -- [UserId] = PlotId
local plotOrder     = {}   -- Plot Model 목록(Plot1→Plot2→… 정렬)
local initialized   = false

-- 유틸: 이름에서 숫자 추출 ("Plot12" → 12, 없으면 math.huge로 맨 뒤)
local function extractPlotNumber(name)
	local num = string.match(name, "%d+")
	return tonumber(num) or math.huge
end

-- 유틸: 모델 이름을 숫자 오름차순(보조 알파벳)으로 정렬
local function sortPlotsByName(a, b)
	local na = extractPlotNumber(a.Name)
	local nb = extractPlotNumber(b.Name)
	if na == nb then
		return a.Name < b.Name
	end
	return na < nb
end

-- 내부: Plots 스캔 + 표준화 + 정렬
local function scanAndOrderPlots()
	assignedPlots = {}
	plotOrder = {}
	for _, plot in ipairs(PlotsFolder:GetChildren()) do
		if plot:IsA("Model") then
			if not plot.PrimaryPart then
				warn(("[PlotAssignmentHandler v1.4a] PrimaryPart 없음: %s (보통 'Base'를 지정하세요)"):format(plot.Name))
			else
				-- Model에 PlotId가 있는지 우선 확인
				local plotId = plot:GetAttribute("PlotId")
				-- 없으면 PrimaryPart의 PlotId를 끌어와서 Model에 승격
				if not plotId and plot.PrimaryPart then
					plotId = plot.PrimaryPart:GetAttribute("PlotId")
					if plotId then
						plot:SetAttribute("PlotId", plotId)
						print(("[PlotAssignmentHandler v1.4a] %s: PrimaryPart의 PlotId를 Model로 승격: %s"):format(plot.Name, plotId))
					end
				end
				-- 그래도 없으면 Model.Name으로 자동 설정(안전장치)
				if not plotId then
					plotId = plot.Name
					plot:SetAttribute("PlotId", plotId)
					warn(("[PlotAssignmentHandler v1.4a] %s: PlotId 미설정 → Model.Name(%s)로 자동 설정"):format(plot.Name, plotId))
				end

				assignedPlots[plotId] = assignedPlots[plotId] == true and assignedPlots[plotId] or false
				table.insert(plotOrder, plot)

				print(("[PlotAssignmentHandler v1.4a] 스캔됨: %s (PlotId=%s)"):format(plot.Name, plotId))
			end
		end
	end
	table.sort(plotOrder, sortPlotsByName)
end

-- 내부: 순서대로 빈 밭 배정
local function assignPlotToPlayer(player)
	for _, plotModel in ipairs(plotOrder) do
		local plotId = plotModel:GetAttribute("PlotId") or plotModel.Name
		local ownerId = assignedPlots[plotId]
		if ownerId == false then
			assignedPlots[plotId] = player.UserId
			playerPlots[player.UserId] = plotId
			print(("[PlotAssignmentHandler v1.4a] %s님이 %s 밭을 배정받았습니다."):format(player.Name, plotId))
			return
		end
	end
	warn(("[PlotAssignmentHandler v1.4a] 배정 실패: 빈 밭이 없습니다 (플레이어=%s)"):format(player.Name))
end

-- 내부: 밭 비우기
local function removePlayerPlot(player)
	local plotId = playerPlots[player.UserId]
	if plotId then
		assignedPlots[plotId] = false
		playerPlots[player.UserId] = nil
		print(("[PlotAssignmentHandler v1.4a] %s님의 %s 밭이 비워졌습니다."):format(player.Name, plotId))
	end
end

-- 공개 API: 소유권 검사
local function isOwner(player, plotModel)
	if not plotModel or not plotModel:IsA("Model") then return false end
	local plotId = plotModel:GetAttribute("PlotId")
	if not plotId and plotModel.PrimaryPart then
		plotId = plotModel.PrimaryPart:GetAttribute("PlotId")
	end
	if not plotId then return false end
	return assignedPlots[plotId] == player.UserId
end

-- 공개 API: 초기화(한 번만)
local function init()
	if initialized then return end
	initialized = true

	scanAndOrderPlots()

	-- 이벤트 연결
	Players.PlayerAdded:Connect(assignPlotToPlayer)
	Players.PlayerRemoving:Connect(removePlayerPlot)

	-- 이미 접속 중인 플레이어 처리(Studio 편의)
	for _, p in ipairs(Players:GetPlayers()) do
		assignPlotToPlayer(p)
	end
end

-- 모듈 테이블 반환
return {
	Init = init,        -- 반드시 서버에서 1회 호출(부트스크립트가 호출)
	IsOwner = isOwner,  -- 서버의 다른 스크립트(예: PlantService)에서 사용
}
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
</roblox>