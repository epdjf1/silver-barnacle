<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="Script" referent="RBX1F31135BF70C4BD79C721D5ED245B246">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">GiveStarterTools</string>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{5D0B50A6-4D9F-4ED3-B0D3-A937DC735049}</string>
			<ProtectedString name="Source"><![CDATA[-- Version 1.1
--[[
  ì—­í• : í…ŒìŠ¤íŠ¸ í¸ì˜ìš©ìœ¼ë¡œ ì…ì¥ ì‹œ TomatoSeedë¥¼ ì§€ê¸‰í•´ì„œ ë°”ë¡œ ì‹¬ì–´ë³¼ ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤.
  ì‹¤ì œ ê²Œì„ì—ì„  ìƒì /ì¸ë²¤í† ë¦¬ì—ì„œ ì§€ê¸‰í•˜ì„¸ìš”.
--]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

Players.PlayerAdded:Connect(function(plr)
	local toolsFolder = ReplicatedStorage:WaitForChild("Tools")
	local tpl = toolsFolder:FindFirstChild("TomatoSeed")
	if tpl and tpl:IsA("Tool") then
		local t = tpl:Clone()
		t.Parent = plr:WaitForChild("Backpack")
		-- ì¬ì…ì¥ ì‹œ ê³„ì† ë“¤ê³  ìˆê²Œ StarterGearì—ë„ ë³µì‚¬(í…ŒìŠ¤íŠ¸ìš©)
		local t2 = tpl:Clone()
		t2.Parent = plr:WaitForChild("StarterGear")
	end
	
	-- â˜… CornSeed ì§€ê¸‰(ì‹ ê·œ)
	local tplCorn = toolsFolder:FindFirstChild("CornSeed")
	if tplCorn and tplCorn:IsA("Tool") then
		tplCorn:Clone().Parent = plr:WaitForChild("Backpack")
		tplCorn:Clone().Parent = plr:WaitForChild("StarterGear")
	end
	
	-- â˜… Axe ì§€ê¸‰(ë²Œëª© í…ŒìŠ¤íŠ¸ìš©)
	local tplAxe = toolsFolder:FindFirstChild("Axe")
	if tplAxe and tplAxe:IsA("Tool") then
		tplAxe:Clone().Parent = plr:WaitForChild("Backpack")
		tplAxe:Clone().Parent = plr:WaitForChild("StarterGear")
	end
end)
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Script" referent="RBX3837F504387E43798ADCED3B2B6FB58A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">HarvestService</string>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{215D00F3-D9F4-4781-8BE1-693A1E27EC8D}</string>
			<ProtectedString name="Source"><![CDATA[-- Version 1.1
--[[
  ìˆ˜í™• ì²˜ë¦¬ ì„œë²„ ìŠ¤í¬ë¦½íŠ¸
  - í´ë¦­ëœ ëŒ€ìƒì´ Plants í•˜ìœ„ ì‘ë¬¼ì¸ì§€ í™•ì¸
  - ë‚´ ì†Œìœ (OwnerUserId) + ìˆ˜í™•ê°€ëŠ¥(Stage==ìµœì¢…ë‹¨ê³„ or IsHarvestable=true) ê²€ì¦
  - PlantConfig.Harvest ì„¤ì •ì„ ì½ì–´ ItemServiceë¡œ Backpack ì§€ê¸‰/ìŠ¤íƒ
  - ì„±ê³µ ì‹œ í•´ë‹¹ ì‘ë¬¼ì„ ì œê±°
--]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local HarvestRequest = Remotes:WaitForChild("HarvestRequest")

local PlantsFolder = workspace:WaitForChild("Plants")

local Plot = require(ServerScriptService:WaitForChild("PlotAssignmentHandler"))
local PlantConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("PlantConfig"))
local ItemService = require(ServerScriptService:WaitForChild("ItemService"))

-- ê°„ë‹¨ ì¿¨ë‹¤ìš´(ìŠ¤íŒ¸ ë°©ì§€)
local lastHarvestAt = {} -- [UserId] = tick()

local function findTopCropModel(inst)
	-- Plants í´ë” ë°”ë¡œ ì•„ë˜ì˜ Modelê¹Œì§€ ê±°ìŠ¬ëŸ¬ ì˜¬ë¼ê°
	local m = inst and inst:FindFirstAncestorOfClass("Model")
	while m and m.Parent ~= PlantsFolder do
		m = m.Parent
		if not m or not m:IsA("Instance") then break end
	end
	if m and m.Parent == PlantsFolder then return m end
	return nil
end

--HarvestRequest.OnServerEvent:Connect(function(player, targetInstance)
--	-- 0) ê°„ë‹¨ ì¿¨ë‹¤ìš´
--	local now = tick()
--	if (lastHarvestAt[player.UserId] or 0) + 0.15 > now then return end
--	lastHarvestAt[player.UserId] = now

--	local cropModel = findTopCropModel(targetInstance)
--	if not cropModel then return end

--	-- 1) ì†Œìœ  ê²€ì‚¬(ì‘ë¬¼ ì†Œìœ ì + í”Œë¡¯ ì†Œìœ ì ëª¨ë‘ í™•ì¸)
--	local ownerId = cropModel:GetAttribute("OwnerUserId")
--	if ownerId ~= player.UserId then return end

--	local plotId = cropModel:GetAttribute("PlotId")
--	local plotsFolder = workspace:FindFirstChild("Plots")
--	local plotModel = plotsFolder and plotId and plotsFolder:FindFirstChild(plotId)
--	if not plotModel or not Plot.IsOwner(player, plotModel) then return end

--	-- 2) ìˆ˜í™• ê°€ëŠ¥ ì—¬ë¶€
--	local cropType = cropModel:GetAttribute("CropType")
--	local stage = cropModel:GetAttribute("Stage") or 1
--	local isHarvestable = cropModel:GetAttribute("IsHarvestable") == true

--	local cfg = cropType and PlantConfig:GetCrop(cropType) or nil
--	if not cfg then return end
--	if not isHarvestable and stage < (cfg.Stages or 1) then
--		-- ì•„ì§ ë¯¸ì„±ìˆ™
--		return
--	end

--	-- 3) ì§€ê¸‰ ì •ë³´
--	local harvest = cfg.Harvest or {ToolName=cropType, Yield=1}
--	local toolName = harvest.ToolName or cropType
--	local yield = harvest.Yield or 1

--	-- 4) ì§€ê¸‰
--	local ok = ItemService.GiveItem(player, toolName, yield)
--	if not ok then return end

--	-- 5) ì‘ë¬¼ ì œê±°
--	cropModel:Destroy()
--end)


-- ê³µí†µ ìˆ˜í™• ì²˜ë¦¬
local function handleHarvest(player, cropModel)
	-- 1) ì†Œìœ /í”Œë¡¯ ê²€ì‚¬
	local ownerId = cropModel:GetAttribute("OwnerUserId")
	if ownerId ~= player.UserId then return end

	local plotId = cropModel:GetAttribute("PlotId")
	local plotsFolder = workspace:FindFirstChild("Plots")
	local plotModel = plotsFolder and plotId and plotsFolder:FindFirstChild(plotId)
	if not plotModel or not Plot.IsOwner(player, plotModel) then return end

	-- 2) ìˆ˜í™• ê°€ëŠ¥ ì—¬ë¶€
	local cropType = cropModel:GetAttribute("CropType")
	local stage = cropModel:GetAttribute("Stage") or 1
	local isHarvestable = cropModel:GetAttribute("IsHarvestable") == true

	local cfg = cropType and PlantConfig:GetCrop(cropType) or nil
	if not cfg then return end
	if not isHarvestable and stage < (cfg.Stages or 1) then return end

	-- 3) ì§€ê¸‰
	local harvest = cfg.Harvest or {ToolName=cropType, Yield=1}
	local ok = ItemService.GiveItem(player, harvest.ToolName or cropType, harvest.Yield or 1)
	if not ok then return end

	-- 4) ì œê±°
	cropModel:Destroy()
end

-- Version 1.3
--[[
  ë³€ê²½ì :
   â–ª í´ë¦­ ìˆ˜í™•(RemoteEvent) ë¹„í™œì„±í™”
   â–ª ìˆ˜í™•ì€ ProximityPrompt(E, HoldDuration)ë§Œ ì‚¬ìš©
--]]

-- ê³µí†µ ìˆ˜í™• ì²˜ë¦¬ (ê¸°ì¡´ ê·¸ëŒ€ë¡œ)
-- local function handleHarvest(player, cropModel) ... end

-- [ì‚­ì œ ëŒ€ì²´] í´ë¦­ ìˆ˜í™•ì€ ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
HarvestRequest.OnServerEvent:Connect(function(player, _)
	warn("[HarvestService v1.3] í´ë¦­ ìˆ˜í™•ì€ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤. Eí‚¤ í”„ë¡¬í”„íŠ¸ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.")
end)

-- E ìˆ˜í™•(ProximityPrompt) ê·¸ëŒ€ë¡œ ìœ ì§€
local function hookPrompt(pp)
	if not (pp and pp:IsA("ProximityPrompt") and pp.Name == "HarvestPrompt") then return end
	pp.Triggered:Connect(function(player)
		local cropModel = pp:FindFirstAncestorOfClass("Model")
		if cropModel and cropModel.Parent == PlantsFolder then
			handleHarvest(player, cropModel)
		end
	end)
end

for _, d in ipairs(PlantsFolder:GetDescendants()) do
	if d:IsA("ProximityPrompt") and d.Name == "HarvestPrompt" then
		hookPrompt(d)
	end
end
PlantsFolder.DescendantAdded:Connect(function(inst)
	if inst:IsA("ProximityPrompt") and inst.Name == "HarvestPrompt" then
		hookPrompt(inst)
	end
end)

]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Script" referent="RBX25C2C62DF16D4BB099D66D75C74736DB">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">PlantService</string>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{6DB6DE01-8AA0-410E-96EB-E25646CFF08E}</string>
			<ProtectedString name="Source"><![CDATA[-- Version 1.4.4

--[[
  ì—­í• : "ì‹¬ê¸° ìš”ì²­ ì²˜ë¦¬ + ì„œë²„ ê²€ì¦ + ì„±ì¥ ë‹¨ê³„ ì§„í–‰"
  ì™œ ì„œë²„ì— ìˆë‚˜ìš”?
   - ì¹˜íŠ¸ ë°©ì§€: ë‚´ ë°­ì¸ì§€, ìë¦¬ ê²¹ì¹¨ ì—†ëŠ”ì§€, ìœ íš¨ íˆ´ì¸ì§€ ë“±ì„ ì„œë²„ì—ì„œ ê²€ì¦í•´ì•¼ ì•ˆì „í•©ë‹ˆë‹¤.

  ì²˜ë¦¬ íë¦„:
   1) í´ë¼ì´ì–¸íŠ¸ê°€ PlantRequest(RemoteEvent)ë¡œ (íˆ´ì´ë¦„, í´ë¦­í•œ Part, í´ë¦­ ìœ„ì¹˜) ì „ì†¡
   2) ì„œë²„ì—ì„œ ë‹¤ìŒì„ ê²€ì¦:
      â–ª í”Œë ˆì´ì–´ê°€ ì‹¤ì œ TomatoSeedë¥¼ ì¥ì°© ì¤‘ì¸ì§€
      â–ª í´ë¦­ ëŒ€ìƒì´ Workspace/Plotsì˜ ë‚´ ë°­ PrimaryPart(Base)ì¸ì§€
      â–ª í•´ë‹¹ ìœ„ì¹˜ì— ë‹¤ë¥¸ ì‘ë¬¼ê³¼ ê°„ê²©(FootprintRadius) ì¶©ëŒ ì—†ëŠ”ì§€
   3) í†µê³¼ ì‹œ Plants í´ë”ì— Crop(Model) ìƒì„±, Stage=1
   4) StageDurationì— ë§ì¶° Stageë¥¼ 2â†’3â†’4ë¡œ ì˜¬ë¦¼ (Stage4ì— IsHarvestable=true)
--]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Players = game:GetService("Players")

local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local PlantRequest = Remotes:WaitForChild("PlantRequest")

local PlantsFolder = workspace:FindFirstChild("Plants") or Instance.new("Folder", workspace)
PlantsFolder.Name = "Plants"

-- ë°­ ê¶Œí•œ ëª¨ë“ˆ (v1.3)
local PlotModule = require(ServerScriptService:WaitForChild("PlotAssignmentHandler"))
local PlantConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("PlantConfig"))

-- ê°„ë‹¨ ìœ í‹¸: 2D í‰ë©´ ê±°ë¦¬(XZ)
local function flatDist(a, b)
	local dx = a.X - b.X
	local dz = a.Z - b.Z
	return math.sqrt(dx*dx + dz*dz)
end

-- ë°”ë‹¥ ìŠ¤ëƒ…: ëª¨ë¸ì˜ ë°”ìš´ë”©ë°•ìŠ¤ í•˜ë‹¨ì„ targetCFrameì˜ Yì— ì •í™•íˆ ë§ì¶˜ë‹¤
local function placeModelOnSurface(model, targetCFrame, extraOffsetY)
	-- 1) ìš°ì„  ëª©í‘œ ìœ„ì¹˜ë¡œ í”¼ë²— ì´ë™
	model:PivotTo(targetCFrame)

	-- 2) í˜„ì¬ ë°”ìš´ë”©ë°•ìŠ¤ ê¸°ì¤€ìœ¼ë¡œ "ë°”ë‹¥ì´ ì–´ë”” ìˆëŠ”ì§€" ê³„ì‚°
	local bboxCf, bboxSize = model:GetBoundingBox()
	local currentBottomY = bboxCf.Position.Y - (bboxSize.Y / 2)

	-- 3) ëª©í‘œ ë°”ë‹¥ Y (HeightOffsetì„ ë”í•´ ì‚´ì§ ë„ì›€)
	local desiredBottomY = targetCFrame.Position.Y + (extraOffsetY or 0)

	-- 4) ì°¨ì´ë§Œí¼ Yë¡œ ë³´ì •
	local deltaY = desiredBottomY - currentBottomY
	if math.abs(deltaY) > 1e-4 then
		model:PivotTo(model:GetPivot() * CFrame.new(0, deltaY, 0))
	end
end


-- ê°™ì€ Plot ìœ„ì— ìˆëŠ” ê¸°ì¡´ ì‘ë¬¼ê³¼ "ê°„ê²©" ì¶©ëŒ ê²€ì‚¬
local function isSpotFree(plotId, pos, radius)
	for _, crop in ipairs(PlantsFolder:GetChildren()) do
		if crop:IsA("Model") and crop:GetAttribute("PlotId") == plotId then
			local cpos = crop:GetAttribute("WorldPos")
			if typeof(cpos) == "Vector3" then
				if flatDist(pos, cpos) < radius * 2 then
					return false
				end
			end
		end
	end
	return true
end

local function setStageVisual(cropModel, cropName, stageIndex)
	-- ì‹œê° ì»¨í…Œì´ë„ˆ ë³´ì¥
	local visualFolder = cropModel:FindFirstChild("Visual") or Instance.new("Folder")
	visualFolder.Name = "Visual"
	visualFolder.Parent = cropModel
	-- ì´ì „ ë¹„ì£¼ì–¼ ì œê±°
	for _, ch in ipairs(visualFolder:GetChildren()) do ch:Destroy() end

	local cfg = PlantConfig:GetCrop(cropName)
	local provider = cfg and cfg.StageModels and cfg.StageModels[stageIndex]
	local prefab = provider and provider()

	-- ì‘ë¬¼ ë£¨íŠ¸ ìœ„ì¹˜(ì›”ë“œ ì¢Œí‘œ)
	local targetCFrame
	if cropModel.PrimaryPart then
		targetCFrame = cropModel.PrimaryPart.CFrame
	else
		-- í˜¹ì‹œ ëª°ë¼ WorldPos Attributeë¡œë„ ë°±ì—…
		local wp = cropModel:GetAttribute("WorldPos")
		targetCFrame = CFrame.new(typeof(wp) == "Vector3" and wp or Vector3.new())
	end

	if prefab and prefab:IsA("Model") then
		local cloned = prefab:Clone()
		cloned.Parent = visualFolder

		-- 1) ëª¨ë“  íŒŒíŠ¸ ì•ˆì „ ì„¤ì •(ë–¨ì–´ì§/ì¶©ëŒ ë°©ì§€)
		for _, d in ipairs(cloned:GetDescendants()) do
			if d:IsA("BasePart") then
				d.Anchored = true
				d.CanCollide = false
			end
		end

		-- 2) PrimaryPart ìë™ ì§€ì •(ì—†ìœ¼ë©´ Root/Base/ì²« BasePart ìˆœ)
		if not cloned.PrimaryPart then
			local basePart = cloned:FindFirstChild("Root")
			if not (basePart and basePart:IsA("BasePart")) then
				basePart = cloned:FindFirstChild("Base")
			end
			if not (basePart and basePart:IsA("BasePart")) then
				for _, p in ipairs(cloned:GetDescendants()) do
					if p:IsA("BasePart") then
						basePart = p; break
					end
				end
			end
			if basePart then
				cloned.PrimaryPart = basePart
			end
		end

		-- PivotTo í›„ ë°”ë‹¥ ìŠ¤ëƒ…ìœ¼ë¡œ ë¯¸ì„¸ ì˜¤í”„ì…‹ì„ ìë™ ë³´ì •
		placeModelOnSurface(cloned, targetCFrame, (cfg and cfg.HeightOffset) or 0)


	else
		-- í”„ë¦¬íŒ¹ì´ ì—†ì„ ë•Œ ì„ì‹œ íŒŒíŠ¸ ìƒì„±(í…ŒìŠ¤íŠ¸ìš©)
		local dummy = Instance.new("Part")
		dummy.Anchored = true
		dummy.CanCollide = false
		dummy.Name = "Stage"..stageIndex
		dummy.Size = Vector3.new(0.8 + stageIndex*0.2, 0.4 + stageIndex*0.2, 0.8 + stageIndex*0.2)
		dummy.CFrame = targetCFrame * CFrame.new(0, dummy.Size.Y/2, 0)
		dummy.Parent = visualFolder
	end
end

-- ìˆ˜í™• í”„ë¡¬í”„íŠ¸(E) ë³´ì¥ í•¨ìˆ˜
-- â–ª ìµœì¢… ë‹¨ê³„ì—ì„œë§Œ ìƒì„±
-- â–ª Ownerë§Œ ëˆŒëŸ¬ë„ ì„œë²„ì—ì„œ ê²€ì¦í•˜ë¯€ë¡œ ì•ˆì „
local function ensureHarvestPrompt(cropModel, cropName)
	local attachParent = cropModel.PrimaryPart or cropModel
	local old = attachParent:FindFirstChild("HarvestPrompt")
	if old and old:IsA("ProximityPrompt") then old:Destroy() end

	local cfg = PlantConfig:GetCrop(cropName)
	local hv  = cfg and cfg.Harvest or {}

	local prompt = Instance.new("ProximityPrompt")
	prompt.Name = "HarvestPrompt"
	prompt.ActionText = "ìˆ˜í™•"
	prompt.ObjectText = cropName
	prompt.KeyboardKeyCode = Enum.KeyCode.E
	prompt.GamepadKeyCode = Enum.KeyCode.ButtonX
	prompt.HoldDuration = hv.HoldDuration or 1.2       -- â˜… ì ìš©
	prompt.RequiresLineOfSight = false
	prompt.MaxActivationDistance = hv.MaxDistance or 12 -- â˜… ì ìš©
	prompt.Style = Enum.ProximityPromptStyle.Default
	prompt.Exclusivity = Enum.ProximityPromptExclusivity.OnePerButton
	-- â˜… í´ë¦­ ë¹„í™œì„±í™”: í”„ë¡¬í”„íŠ¸ UI í´ë¦­ìœ¼ë¡œëŠ” íŠ¸ë¦¬ê±°ë˜ì§€ ì•ŠìŒ (Eí‚¤/íŒ¨ë“œë§Œ)
	prompt.ClickablePrompt = false
	prompt.Parent = attachParent
end


-- ìˆ˜í™• í”„ë¡¬í”„íŠ¸ ì œê±°(ìµœì¢…ë‹¨ê³„ê°€ ì•„ë‹ ë•Œ)
local function removeHarvestPrompt(cropModel)
	local attachParent = cropModel.PrimaryPart or cropModel
	local p = attachParent:FindFirstChild("HarvestPrompt")
	if p and p:IsA("ProximityPrompt") then p:Destroy() end
end


--[v1.4+]
local function scheduleGrowth(cropModel, cropName)
	local cfg = PlantConfig:GetCrop(cropName)
	if not cfg then return end

	local stage = cropModel:GetAttribute("Stage") or 1
	-- ì‹œê° ì—…ë°ì´íŠ¸
	setStageVisual(cropModel, cropName, stage)

	if stage >= cfg.Stages then
		-- ìµœì¢…ë‹¨ê³„: ìˆ˜í™• ê°€ëŠ¥ + E í”„ë¡¬í”„íŠ¸ ìƒì„±
		cropModel:SetAttribute("IsHarvestable", true)
		ensureHarvestPrompt(cropModel, cropName)
		return
	end

	-- ìµœì¢…ë‹¨ê³„ê°€ ì•„ë‹ˆë¼ë©´ í”„ë¡¬í”„íŠ¸ ì œê±°(í˜¹ì‹œ ë‚¨ì•„ìˆì„ ìˆ˜ë„ ìˆìœ¼ë‹ˆ)
	removeHarvestPrompt(cropModel)

	-- ë‹¤ìŒ ë‹¨ê³„ ì˜ˆì•½
	local delaySec = cfg.StageDuration[stage] or 10
	task.delay(delaySec, function()
		if cropModel and cropModel.Parent then
			cropModel:SetAttribute("Stage", stage + 1)
			scheduleGrowth(cropModel, cropName)
		end
	end)
end


-- ì„œë²„: ì‹¬ê¸° ìš”ì²­ ì²˜ë¦¬
PlantRequest.OnServerEvent:Connect(function(player, toolName, clickedPart, hitPos)
	-- 1) ê¸°ë³¸ íƒ€ì… ì²´í¬ (toolNameì€ ë” ì´ìƒ ì‹ ë¢°í•˜ì§€ ì•ŠìŒ)
	if typeof(clickedPart) ~= "Instance" or typeof(hitPos) ~= "Vector3" then
		warn("[PlantService] ì˜ëª»ëœ ì¸ì")
		return
	end

	-- 2) ì¥ì°© íˆ´ ê²€ì¦(ì´ë¦„ ë¹„êµ ì œê±°)
	local char = player.Character
	local tool = char and char:FindFirstChildOfClass("Tool")
	if not tool then
		warn("[PlantService] ë¯¸ì¥ì°©")
		return
	end

	-- Seed íˆ´ ì—¬ë¶€: CropType StringValueê°€ ìˆì–´ì•¼ í•¨
	local cropTypeValue = tool:FindFirstChild("CropType")
	if not (cropTypeValue and cropTypeValue:IsA("StringValue")) then
		warn("[PlantService] ì”¨ì•— íˆ´ ì•„ë‹˜")
		return
	end

	-- 3) ì‘ë¬¼ íƒ€ì… í™•ì¸ (íˆ´ ë©”íƒ€ ìš°ì„ , ëŒ€ì†Œë¬¸ì ë¬´ì‹œ + Seed ì ‘ë¯¸ì‚¬ ì œê±° í´ë°±)
	local function normalizeCropName(s: string?): string?
		if typeof(s) ~= "string" or s == "" then return nil end
		-- ê³µë°± íŠ¸ë¦¼ + ëŒ€ì†Œë¬¸ì ì •ê·œí™”(ì²« ê¸€ìë§Œ ëŒ€ë¬¸ì, ë‚˜ë¨¸ì§€ ì†Œë¬¸ì)
		s = s:gsub("^%s+", ""):gsub("%s+$", "")
		local lower = s:lower()
		-- "tomatoseed" â†’ "tomato"
		if lower:sub(-4) == "seed" then
			lower = lower:sub(1, #lower-4)
		end
		-- ì²« ê¸€ì ëŒ€ë¬¸ìí™”(PlantConfigê°€ "Tomato"/"Corn"ì²˜ëŸ¼ TitleCaseì¼ ë•Œ ëŒ€ì‘)
		return lower:sub(1,1):upper() .. lower:sub(2)
	end

	local cropName: string? = nil

	-- 3-1) Tool ë‚´ë¶€ StringValue("CropType")ë¥¼ ìš°ì„  ì‹ ë¢°
	local cropTypeValue = tool:FindFirstChild("CropType")
	if cropTypeValue and cropTypeValue:IsA("StringValue") then
		cropName = normalizeCropName(cropTypeValue.Value)
	end

	-- 3-2) í´ë°±: Tool.Nameì´ TomatoSeed/CornSeedë¼ë©´ Seed ì œê±°í•´ì„œ ì‹œë„
	if (not cropName) or (not PlantConfig:GetCrop(cropName)) then
		cropName = normalizeCropName(tool.Name)
	end

	-- ìµœì¢… ê²€ì¦
	if not cropName or not PlantConfig:GetCrop(cropName) then
		warn("[PlantService] ì•Œ ìˆ˜ ì—†ëŠ” ì‘ë¬¼ íƒ€ì…: ", cropName)
		return
	end



	-- 4) í´ë¦­ ëŒ€ìƒì´ Workspace/Plotsì˜ ë‚´ ë°­ PrimaryPart(Base)ì¸ì§€ í™•ì¸
	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then
		warn("[PlantService] Plots í´ë” ì—†ìŒ")
		return
	end

	local plotModel = clickedPart and clickedPart:FindFirstAncestorOfClass("Model")
	if not plotModel or plotModel.Parent ~= plotsFolder then
		warn("[PlantService] í´ë¦­ ëŒ€ìƒì´ Plots í•˜ìœ„ê°€ ì•„ë‹˜")
		return
	end

	if plotModel.PrimaryPart ~= clickedPart then
		-- Base(PrimaryPart)ë¥¼ í´ë¦­í•´ì•¼ ì‹¬ì–´ì§€ë„ë¡ ê°•ì œ (ê°„ë‹¨/ì•ˆì „)
		warn("[PlantService] PrimaryPartê°€ ì•„ë‹Œ ê³³ í´ë¦­ë¨ (Baseë¥¼ í´ë¦­í•˜ì„¸ìš”)")
		return
	end

	-- 5) ë‚´ ë°­ì¸ì§€ ê¶Œí•œ í™•ì¸
	if not PlotModule.IsOwner(player, plotModel) then
		warn("[PlantService] ì†Œìœ ì ì•„ë‹˜: "..player.Name)
		return
	end

	-- 6) ì‹¬ê¸° ìœ„ì¹˜ ë³´ì •(í”Œë¡¯ì˜ ë¡œì»¬ ì¢Œí‘œë¡œ ë³€í™˜í•˜ì—¬ í‘œë©´ì— ì •í™•íˆ ìŠ¤ëƒ…)
	local base = plotModel.PrimaryPart
	local cfg = PlantConfig:GetCrop(cropName)

	-- 6-1) ì›”ë“œâ†’ë¡œì»¬: í´ë¦­ ì§€ì ì„ í”Œë¡¯ ê¸°ì¤€ ì¢Œí‘œë¡œ ë³€í™˜
	local localPoint = base.CFrame:PointToObjectSpace(hitPos)

	-- 6-2) í‘œë©´ Y(í”Œë¡¯ ë‘ê»˜/2 + ì•½ê°„ì˜ ë„ì›€)ë¡œ ê³ ì •
	local surfaceY = (base.Size.Y / 2) + (cfg.HeightOffset or 0.1)

	-- (ì„ íƒ) ê°€ì¥ìë¦¬ í´ë¨í”„ ì˜ˆì‹œ â€” í•„ìš” ì‹œ ì£¼ì„ í•´ì œ
	-- local margin = cfg.FootprintRadius or 1
	-- local clampX = math.clamp(localPoint.X, -base.Size.X/2 + margin, base.Size.X/2 - margin)
	-- local clampZ = math.clamp(localPoint.Z, -base.Size.Z/2 + margin, base.Size.Z/2 - margin)
	-- localPoint = Vector3.new(clampX, localPoint.Y, clampZ)

	-- 6-3) ë¡œì»¬â†’ì›”ë“œ: ìµœì¢… ì›”ë“œ ì¢Œí‘œ ì‚°ì¶œ
	local pos = base.CFrame:PointToWorldSpace(Vector3.new(localPoint.X, surfaceY, localPoint.Z))


	-- 7) ê¸°ì¡´ ì‘ë¬¼ê³¼ ê°„ê²© ì¶©ëŒ ì²´í¬
	local plotId = plotModel:GetAttribute("PlotId") or plotModel.Name
	if not isSpotFree(plotId, pos, cfg.FootprintRadius) then
		warn("[PlantService] ë„ˆë¬´ ê°€ê¹Œì›Œì„œ ì‹¬ì„ ìˆ˜ ì—†ìŒ")
		return
	end

	-- 8) ì‘ë¬¼ ëª¨ë¸ ìƒì„±
	local cropModel = Instance.new("Model")
	cropModel.Name = cropName .. "_Crop"
	cropModel:SetAttribute("CropType", cropName)
	cropModel:SetAttribute("OwnerUserId", player.UserId)
	cropModel:SetAttribute("PlotId", plotId)
	cropModel:SetAttribute("Stage", 1)
	cropModel:SetAttribute("IsHarvestable", false)
	cropModel:SetAttribute("WorldPos", pos)

	-- ìœ„ì¹˜ë¥¼ ê³ ì •í•˜ê¸° ìœ„í•œ ì•µì»¤ íŒŒíŠ¸(ë£¨íŠ¸ ì—­í• )
	local root = Instance.new("Part")
	root.Name = "Root"
	root.Anchored = true
	root.CanCollide = false
	root.Size = Vector3.new(0.2, 0.2, 0.2)
	root.CFrame = CFrame.new(pos)
	root.Parent = cropModel
	cropModel.PrimaryPart = root
	-- ì‹œê°/ë¬¼ë¦¬ ë…¸ì¶œì„ ì™„ì „íˆ ë”
	root.Transparency = 1
	root.CastShadow = false
	root.CanQuery = false
	root.CanTouch = false


	cropModel.Parent = PlantsFolder

	-- 9) ë¹„ì£¼ì–¼ í‘œì‹œ ë° ì„±ì¥ ì‹œì‘
	scheduleGrowth(cropModel, cropName)
end)
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Script" referent="RBXA688FB37506A47849CC9FD86FCC13F72">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">PlotAssignmentBootstrap</string>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{BFF41ACB-16E4-40D4-86EB-B8CDF05C8C29}</string>
			<ProtectedString name="Source"><![CDATA[-- Version 1.0
--[[
  ì—­í• : PlotAssignmentHandler(ëª¨ë“ˆ)ì„ ì„œë²„ ì‹œì‘ ì‹œì ì— 1íšŒ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
  ë¶„ë¦¬ ì´ìœ : ModuleScriptëŠ” 'require'ë  ë•Œë§Œ ì‹¤í–‰ë˜ë¯€ë¡œ, ì„œë²„ ê³µí†µ ì´ˆê¸°í™”ë¥¼ ë³´ì¥í•˜ê¸° ìœ„í•¨ì…ë‹ˆë‹¤.
--]]

local ServerScriptService = game:GetService("ServerScriptService")
local Plot = require(ServerScriptService:WaitForChild("PlotAssignmentHandler"))
Plot.Init()  -- í•œ ë²ˆë§Œ í˜¸ì¶œë˜ë©°, ë‚´ë¶€ ê°€ë“œë¡œ ì¤‘ë³µ ì´ˆê¸°í™” ë°©ì§€
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Script" referent="RBX514F00C4CAB54B949278503A5E459A08">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">RemotesBootstrap</string>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{80528220-3A20-470A-9A7E-279B1B70DCF2}</string>
			<ProtectedString name="Source"><![CDATA[-- Version 1.0
--[[
  ì„œë²„ ì‹œì‘ ì‹œ Remotesë¥¼ ë³´ì¥ ìƒì„±í•©ë‹ˆë‹¤.
  - ReplicatedStorage/Remotes (Folder)
  - RemoteEvent: PlantRequest, HarvestRequest
--]]
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local remotes = ReplicatedStorage:FindFirstChild("Remotes")
if not remotes then
	remotes = Instance.new("Folder")
	remotes.Name = "Remotes"
	remotes.Parent = ReplicatedStorage
end

local function ensureRemote(name)
	local r = remotes:FindFirstChild(name)
	if not r then
		r = Instance.new("RemoteEvent")
		r.Name = name
		r.Parent = remotes
	end
	return r
end

ensureRemote("PlantRequest")
ensureRemote("HarvestRequest")
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Script" referent="RBXB4B7ABB9D50749659D4FC084DF3A8432">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">ResourceService</string>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{F32932D7-A034-4B59-859B-16CEEBE4EB85}</string>
			<ProtectedString name="Source"><![CDATA[--Version v1.5.3

--[[
  ğŸª“ ResourceService (ë²Œëª© ì„œë²„ ë¡œì§)
  ëª©ì : ë‚˜ë¬´(ìì› ë…¸ë“œ)ë¥¼ Eí‚¤ í”„ë¡¬í”„íŠ¸ë¡œ "ì—¬ëŸ¬ ë²ˆ" íƒ€ê²©í•´ì„œ ë² ê³ , ë³´ìƒì„ ì§€ê¸‰/ë¦¬ìŠ¤í°í•œë‹¤.
  ì™œ ì„œë²„ì—ì„œ í•˜ë‚˜ë¡œ ê´€ë¦¬í•˜ë‚˜ìš”?
   - ì¹˜íŠ¸ ë°©ì§€: Axe ì¥ì°© ì—¬ë¶€/ê±°ë¦¬/ì¤‘ë³µ íƒ€ê²©ì€ ì„œë²„ì—ì„œë§Œ ì‹ ë¢° ê°€ëŠ¥
   - ë™ì‹œ ì ‘ì†ìë“¤ì´ ê°™ì€ ë‚˜ë¬´ë¥¼ ì¹˜ëŠ” ê²½ìš°ë¥¼ ì•ˆì •ì ìœ¼ë¡œ ì¡°ì •

  ë™ì‘ ìš”ì•½:
   1) Workspace/Treesë¥¼ ìŠ¤ìº” â†’ ê° Tree Modelì— NodeType/HP/MaxHPë¥¼ ë³´ì¥, ProximityPrompt ë¶€ì°©
   2) í”Œë ˆì´ì–´ê°€ E ëˆ„ë¥´ë©´(í™€ë“œ) â†’ Axe ì¥ì°© ê²€ì¦ â†’ HP -1 â†’ 0ì´ë©´ ë³´ìƒ ì§€ê¸‰ + ë‚˜ë¬´ ìˆ¨ê¹€ + ë¦¬ìŠ¤í° íƒ€ì´ë¨¸
   3) RespawnSeconds í›„ HP=MaxHP ë³µêµ¬, í”„ë¡¬í”„íŠ¸ ì¬ìƒì„±, ë‹¤ì‹œ ë²Œëª© ê°€ëŠ¥
   
   --Version v1.5.3
   HP0ë¡œ ì“°ëŸ¬ì ¸ ë³´ìƒ ì§€ê¸‰í•˜ëŠ” êµ¬ê°„ì— ì¸ë²¤í† ë¦¬ ë°˜ì˜ + í”½ì—… ì´ë²¤íŠ¸ ì†¡ì‹ ì„ ì •í™•íˆ ì¶”ê°€.
--]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local ServerScriptService = game:GetService("ServerScriptService")
-- [ì¶”ê°€] ì²´ë ¥ UI ëª¨ë“ˆ ë¡œë“œ

local TweenService = game:GetService("TweenService") -- â˜… ëª¨ë¸ ê¸°ìš¸ê¸°/íˆ¬ëª… ì• ë‹ˆìš©
-- â˜… FX ëª¨ë“ˆ(í”ë“¤ë¦¼/ìš°ìˆ˜ìˆ˜ ë²„ìŠ¤íŠ¸)
local EffectLib = require(game.ReplicatedStorage:WaitForChild("Shared"):WaitForChild("FX"):WaitForChild("EffectLib"))
-- â˜… Loot í”½ì—… ì•Œë¦¼ìš© RemoteEvent ë³´ì¥
local remotes = ReplicatedStorage:FindFirstChild("Remotes") or Instance.new("Folder", ReplicatedStorage); remotes.Name = "Remotes"
local lootFolder = remotes:FindFirstChild("Loot") or Instance.new("Folder", remotes); lootFolder.Name = "Loot"
local evPicked = lootFolder:FindFirstChild("Picked") or Instance.new("RemoteEvent", lootFolder); evPicked.Name = "Picked"


-- Version 1.3.2 hotfix: forward declarations
-- (ë‚˜ì¤‘ì— 'í•¨ìˆ˜ = function() end'ë¡œ ëŒ€ì…í•´ì„œ ì •ì˜í•©ë‹ˆë‹¤)
local ensureChopPrompt
local setTreeGrowthVisual
--Version v1.3.7
local setTreeVisual          -- â˜… Watcherì—ì„œ í˜¸ì¶œí•˜ë¯€ë¡œ ì „ë°©ì„ ì–¸ ì¶”ê°€
local removeChopPrompt       -- â˜… ì „ë°©ì„ ì–¸ì„ ì‹¤ì œë¡œ ì‚¬ìš© (ì•„ë˜ ì •ì˜ë„ localë¡œ ë°”ê¿ˆ)


-- í•„ìš”ì‹œ removeChopPromptë„ ì „ë°© ì„ ì–¸ì´ í•„ìš”í•˜ë‹¤ë©´ ì•„ë˜ ì£¼ì„ í•´ì œ
-- local removeChopPrompt
local TreesFolder = workspace:WaitForChild("Trees")  -- â˜… ë‚˜ë¬´ ëª¨ìŒ í´ë”

local ResourceConfig = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("ResourceConfig"))
local ItemService = require(ServerScriptService:WaitForChild("ItemService"))

--ë””ë²„ê·¸ ì‘ë™
local DEBUG = true  -- í•„ìš” ì—†ìœ¼ë©´ false

local function dprint(...)
	if DEBUG then
		print("[ResourceService]", ...)
	end
end



--[[
  setModelVisible (v1.3.9)
  ì—­í• : ëª¨ë¸ì˜ 'ê²‰ëª¨ìŠµ'ë§Œ ë³´ì´ê±°ë‚˜ ìˆ¨ê¹€. Trunk(PrimaryPart)ëŠ” ê±´ë“œë¦¬ì§€ ì•ŠìŒ.
  ì™œ ì´ë ‡ê²Œ? ì„±ì¥ ë‹¨ê³„ì—ì„œ Trunkê°€ ë‹¤ì‹œ ë‚˜íƒ€ë‚˜ Grow1/2ë¥¼ ê°€ë¦¬ëŠ” ë¬¸ì œë¥¼ ë°©ì§€.
]]
-- Version v1.4.0: Visual í´ë” ì „ìš© ë³´/ìˆ¨ (TrunkëŠ” ì ˆëŒ€ ê±´ë“œë¦¬ì§€ ì•ŠìŒ)
local function setModelVisible(model, visible)
	-- Visual í´ë”ê°€ ì—†ìœ¼ë©´ ë§Œë“¤ì–´ ë‘”ë‹¤ (ì•ˆì „)
	local visual = model:FindFirstChild("Visual")
	if not visual then
		visual = Instance.new("Folder")
		visual.Name = "Visual"
		visual.Parent = model
	end

	for _, d in ipairs(visual:GetDescendants()) do
		if d:IsA("BasePart") then
			d.Anchored = true
			d.CanCollide = false
			d.Transparency = visible and 0 or 1
		end
	end
end


--[[
  setTrunkHidden (v1.3.9)
  ì—­í• : Trunk(PrimaryPart)ë¥¼ í•­ìƒ ìˆ¨ê¹€/í‘œì‹œ ì œì–´. ìš°ë¦¬ëŠ” 'í•­ìƒ ìˆ¨ê¹€'ìœ¼ë¡œ ì‚¬ìš©.
  ì´ìœ : í”„ë¡¬í”„íŠ¸/Pivot ì „ìš©ìœ¼ë¡œ ì“°ê³ , ì‹¤ì œ ì™¸í˜•ì€ Visual í”„ë¦¬íŒ¹ì´ ê·¸ë¦°ë‹¤.
]]
local function setTrunkHidden(model, hidden)
	local trunk = model.PrimaryPart or model:FindFirstChild("Trunk")
	if trunk and trunk:IsA("BasePart") then
		trunk.Transparency = hidden and 1 or 0
		trunk.CanCollide = true  -- ê¸°ì¤€ íŒŒíŠ¸ì´ë¯€ë¡œ ì¶©ëŒì€ ì¼œ ë‘ (ì›í•˜ë©´ false ê°€ëŠ¥)
	end
end


-- â˜… Visual í´ë” í•˜ìœ„ íŒŒì¸ ë¥¼ 'ë¬´ì¡°ê±´' ë³´ì´ê²Œ ê°•ì œ ë³µêµ¬
--    (ë² ê¸° ì• ë‹ˆ/ìŠ¤íŠ¸ë¦¬ë°/íƒ€ì´ë° ì´ìŠˆë¡œ íˆ¬ëª…Â·ì¶©ëŒ ì„¤ì •ì´ ë‚¨ëŠ” ê²½ìš°ë¥¼ ì›ì²œ ì°¨ë‹¨)
local function forceVisualVisible(model)
	local visual = model:FindFirstChild("Visual")
	if not visual then return end
	for _, d in ipairs(visual:GetDescendants()) do
		if d:IsA("BasePart") then
			d.Anchored = true        -- ì•ˆì „: ë¬¼ë¦¬ ì˜í–¥ ì œê±°
			d.CanCollide = false     -- ì„±ì¥ ë‹¨ê³„ ì˜¤ë¸Œì íŠ¸ëŠ” ì¶©ëŒ X
			d.Transparency = 0       -- â˜… í•­ìƒ ë³´ì´ê²Œ
		end
	end
end

-- ì¸ë²¤í† ë¦¬ ë³´ì¥
-- â˜… Inventory(IntValue) ë³´ì¥ ìœ í‹¸ - Shop ì‹œìŠ¤í…œê³¼ í˜¸í™˜
local function ensureInventory(player: Player)
	local folderName = "Inventory"
	local f = player:FindFirstChild(folderName)
	if not f then
		f = Instance.new("Folder")
		f.Name = folderName
		f.Parent = player
	end
	return f
end

local function ensureItem(inv: Folder, id: string)
	local v = inv:FindFirstChild(id)
	if not v then
		v = Instance.new("IntValue")
		v.Name = id
		v.Value = 0
		v.Parent = inv
	end
	return v
end



-- í”„ë¡¬í”„íŠ¸ ìƒì„±/ì œê±°
removeChopPrompt = function(model)
	local attach = model.PrimaryPart or model
	local old = attach:FindFirstChild("ChopPrompt")
	if old and old:IsA("ProximityPrompt") then old:Destroy() end
end

-- Version 1.2 ë³´ê°• í•¨ìˆ˜ë“¤ ----------------------------

-- â˜… ì›ë˜ íŠ¸ë¦¬ì˜ ì‹œê° íŒŒì¸  ë¹„ìš°ê¸°(ë¦¬ìŠ¤í° ì „ì— ê¹¨ë—ì´)
local function clearTreeVisual(model)
	local visual = model:FindFirstChild("Visual")
	if visual then
		for _, ch in ipairs(visual:GetChildren()) do ch:Destroy() end
	end
end

-- â˜… HP0ì—ì„œ ì‹¤í–‰: íŠ¸ë í¬ë¥¼ 'ë°”ë‹¥ì—ì„œ íšŒì „'ì‹œí‚¤ë©° ì ì  íˆ¬ëª…í•˜ê²Œ
--    - playerë¥¼ ê¸°ì¤€ìœ¼ë¡œ 'í”Œë ˆì´ì–´ ë°˜ëŒ€ ë°©í–¥'ìœ¼ë¡œ ì“°ëŸ¬ì§€ê²Œ ì²˜ë¦¬(ì•ˆì „)
local function playFellAnimation(model, player, tweenSec)
	-- 1) í•„ìˆ˜ íŒŒíŠ¸ í™•ë³´
	local trunk = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
	if not trunk then return end

	-- 2) ì‹œì‘/ëª©í‘œ CFrame ê³„ì‚°(ë°”ë‹¥ ì¶•ì„ ì¤‘ì‹¬ìœ¼ë¡œ ê¸°ìš¸ê¸°)
	local startCF = trunk.CFrame
	local halfH = trunk.Size.Y / 2

	-- í”Œë ˆì´ì–´ ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ë„˜ì–´ì§€ë„ë¡ ë°©í–¥ ë²¡í„° ê³„ì‚°
	local fallDir = trunk.CFrame.LookVector -- ê¸°ë³¸
	if player and player.Character and player.Character.PrimaryPart then
		local away = (trunk.Position - player.Character.PrimaryPart.Position)
		fallDir = Vector3.new(away.X, 0, away.Z)
		if fallDir.Magnitude < 1e-3 then
			fallDir = trunk.CFrame.LookVector
		else
			fallDir = fallDir.Unit
		end
	end

	-- íŠ¸ë í¬ ìœ„ì¹˜ì—ì„œ 'ë„˜ì–´ì§ˆ ë°©í–¥'ìœ¼ë¡œ ë°”ë¼ë³´ê²Œ í•˜ê³ , ë°”ë‹¥ì¶•ì—ì„œ -70Âº ê¸°ìš¸ì„
	local yaw = CFrame.new(startCF.Position, startCF.Position + fallDir)
	local tilt = CFrame.Angles(math.rad(-70), 0, 0)
	local targetCF = yaw * CFrame.new(0, -halfH, 0) * tilt * CFrame.new(0, halfH, 0)

	-- 3) íšŒì „/íˆ¬ëª… íŠ¸ìœˆ ìƒì„± í›„ ì‹¤í–‰(ë™ì‹œ)
	local tinfo = TweenInfo.new(tweenSec or 0.65, Enum.EasingStyle.Cubic, Enum.EasingDirection.In)
	local rotTween = TweenService:Create(trunk, tinfo, { CFrame = targetCF })

	-- ëª¨ë“  íŒŒì¸  íˆ¬ëª…í™”(ì•µì»¤/ë¹„ì¶©ëŒ ë³´ì¥)
	local parts = {}
	for _, d in ipairs(model:GetDescendants()) do
		if d:IsA("BasePart") then
			d.Anchored = true
			d.CanCollide = false
			table.insert(parts, d)
		end
	end
	for _, p in ipairs(parts) do
		TweenService:Create(p, TweenInfo.new(tweenSec or 0.65, Enum.EasingStyle.Quad, Enum.EasingDirection.In), { Transparency = 1 }):Play()
	end

	rotTween:Play()
	rotTween.Completed:Wait()

	-- 4) ìˆ¨ê¸°ê³ , íŠ¸ë í¬ ìì„¸ëŠ” ì›ë³µ(ë¦¬ìŠ¤í° ì‹œ ë˜‘ë°”ë¡œ ë‚˜ì˜¤ê²Œ)
	setModelVisible(model, false)
	trunk.CFrame = startCF
	clearTreeVisual(model)
end
-- -----------------------------------------------------


-- â˜… ì›ë˜ íŠ¸ë¦¬ì˜ ì‹œê° íŒŒì¸ ë¥¼ Visual í´ë”ë¡œ ê²©ë¦¬í•˜ê³  ìˆ¨ê¹€
local function quarantineOriginalVisual(model)
	-- Visual í´ë” ë³´ì¥
	local visual = model:FindFirstChild("Visual")
	if not visual then
		visual = Instance.new("Folder")
		visual.Name = "Visual"
		visual.Parent = model
	end

	-- PrimaryPart(Trunk)ì™€ ProximityPromptë¥¼ ì œì™¸í•œ ìì‹ë“¤ì„ Visualë¡œ ì´ë™
	for _, ch in ipairs(model:GetChildren()) do
		if ch ~= visual and ch ~= model.PrimaryPart and not ch:IsA("ProximityPrompt") then
			ch.Parent = visual
		end
	end

	-- ê²©ë¦¬ëœ ê¸°ì¡´ íŒŒì¸ ëŠ” ì „ë¶€ ìˆ¨ê¹€ + ë¹„ì¶©ëŒ ì²˜ë¦¬
	for _, d in ipairs(visual:GetDescendants()) do
		if d:IsA("BasePart") then
			d.Anchored = true
			d.CanCollide = false
			d.Transparency = 1
		end
	end
end


-- â˜… íŠ¸ë¦¬ ì™¸í˜• ì œê±°(Visual í´ë” ì •ë¦¬)
local function removeTreeVisual(model)
	local visual = model:FindFirstChild("Visual")
	if visual then
		for _, ch in ipairs(visual:GetChildren()) do ch:Destroy() end
	else
		visual = Instance.new("Folder")
		visual.Name = "Visual"
		visual.Parent = model
	end
end

--[[
  v1.4.1 placeOnTrunk
  ëª©ì : í”„ë¦¬íŒ¹ì˜ "ì§„ì§œ ë°”ë‹¥"ì„ íŠ¸ë í¬ ë°”ë‹¥ ë†’ì´ì— ì •í™•íˆ ë§ì¶˜ë‹¤.
  ì›ë¦¬:
   1) í”„ë¦¬íŒ¹ Pivot ê¸°ì¤€ ë¡œì»¬ ì¢Œí‘œê³„ë¡œ ê° BasePartì˜ 'ë°”ë‹¥ Y'(ë¡œì»¬Y - Size.Y/2)ë¥¼ ê³„ì‚°
   2) ê·¸ ì¤‘ ìµœì†Ÿê°’ì´ ëª¨ë¸ì˜ "ì§„ì§œ ë°”ë‹¥ ì˜¤í”„ì…‹"(minBottom) â†’ pivotì´ ì¤‘ì•™/ìƒë‹¨/í•˜ë‹¨ ì–´ë””ë“  ë³´ì • ê°€ëŠ¥
   3) íŠ¸ë í¬ ë°”ë‹¥ ë†’ì´(íŠ¸ë í¬ ì¤‘ì‹¬Y - íŠ¸ë í¬ì ˆë°˜ë†’ì´)ì— -minBottomì„ ë”í•´ ìµœì¢… Yë¥¼ ë§Œë“ ë‹¤
]]
function placeOnTrunk(prefabModel, trunkCF, trunkPart)
	-- 0) ë¬¼ë¦¬ ì¶©ëŒ/ì•µì»¤ ìƒíƒœ ì •ë¦¬ (ê²‰ëª¨ìŠµì´ë¯€ë¡œ ê³ ì •)
	for _, d in ipairs(prefabModel:GetDescendants()) do
		if d:IsA("BasePart") then
			d.Anchored = true
			d.CanCollide = false
		end
	end

	-- 1) íŠ¸ë í¬ì˜ íšŒì „(ë°©í–¥)ë§Œ ë¯¸ë¦¬ ë³µì‚¬í•´ ë‘˜ ì˜¤ë¦¬ì—”í…Œì´ì…˜ í–‰ë ¬
	local orientation = (trunkCF - trunkCF.Position)

	-- 2) í”„ë¦¬íŒ¹ì˜ Pivot ê¸°ì¤€ 'ì§„ì§œ ë°”ë‹¥ ì˜¤í”„ì…‹' ê³„ì‚°
	local pivotCF = prefabModel:GetPivot()
	local minBottom = math.huge
	for _, d in ipairs(prefabModel:GetDescendants()) do
		if d:IsA("BasePart") then
			-- íŒŒì¸ ì˜ 'Pivot ë¡œì»¬ì¢Œí‘œ'ë¡œ ë³€í™˜
			local localCF = pivotCF:ToObjectSpace(d.CFrame)
			-- ì´ íŒŒì¸ ì˜ ë°”ë‹¥ Y (ë¡œì»¬)
			local bottomY = localCF.Position.Y - d.Size.Y/2
			if bottomY < minBottom then
				minBottom = bottomY
			end
		end
	end
	if minBottom == math.huge then
		minBottom = 0 -- íŒŒì¸ ê°€ ì—†ìœ¼ë©´ 0 ë³´ì •
	end

	-- 3) íŠ¸ë í¬ ë°”ë‹¥ ë†’ì´(= íŠ¸ë í¬ ì¤‘ì‹¬Y - ì ˆë°˜ë†’ì´)
	local trunkHalf = 0
	if trunkPart and trunkPart:IsA("BasePart") then
		trunkHalf = trunkPart.Size.Y / 2
	end
	local trunkBottomY = trunkCF.Position.Y - trunkHalf

	-- 4) ìµœì¢… ë°°ì¹˜ ìœ„ì¹˜ = (íŠ¸ë í¬ XZ, ë°”ë‹¥Y + 'ë°”ë‹¥ ì˜¤í”„ì…‹ ë³´ì •')
	local targetPos = Vector3.new(
		trunkCF.Position.X,
		trunkBottomY - minBottom, -- minBottomì€ ë³´í†µ ìŒìˆ˜ â†’ -minBottom ë§Œí¼ ì˜¬ë¦¼
		trunkCF.Position.Z
	)

	-- 5) íŠ¸ë í¬ì˜ íšŒì „ì€ ìœ ì§€í•˜ê³ , ìœ„ì¹˜ë§Œ targetPosë¡œ
	local targetCF = CFrame.new(targetPos) * orientation
	prefabModel:PivotTo(targetCF)
end

--[[
  playHPChangeFX
  ì—­í• : HP ì „í™˜(HP3->HP2, HP2->HP1 ë“±) ì§í›„, ìƒˆ ì™¸í˜•(root)ì— í”ë“¤ë¦¼ê³¼ íŒŒí‹°í´ ë²„ìŠ¤íŠ¸ë¥¼ ì¬ìƒ.
  ì™œ ì´ë ‡ê²Œ?  ë² ê¸° íƒ€ê²©ê°ì„ ëª…í™•íˆ ì „ë‹¬í•˜ê³ , ì™¸í˜• ì „í™˜ê³¼ ë™ì‹œì— ìì—°ìŠ¤ëŸ¬ìš´ í”¼ë“œë°± ì œê³µ.
]]
local function playHPChangeFX(model: Model, newRoot: Instance, prevHP: number, newHP: number)
	-- 1) í”ë“¤ë¦¼(ì‘ê²Œ)
	task.spawn(function()
		-- ì”ë ‰ ë°©ì§€: ë¹„ë™ê¸°ë¡œ
		EffectLib.ShakeInstance(newRoot, math.rad(10), 0.14)
	end)

	-- 2) íŒŒí¸/ì ë²„ìŠ¤íŠ¸: íŠ¸ë í¬ ìœ„ì¹˜ì—ì„œ ë°©ì¶œ
	local trunkCF = (model.PrimaryPart and model.PrimaryPart.CFrame) or model:GetPivot()
	-- HPê°€ ë‚®ì„ìˆ˜ë¡(ë§ˆì§€ë§‰ ì¼ê²©) ì¡°ê¸ˆ ë” ë§ê²Œ
	local base = 60
	local add  = (prevHP == 2 and newHP == 1) and 30 or 15
	EffectLib.EmitBurstAt(trunkCF * CFrame.new(0, 1.8, 0), nil, base + add)
end



-- â˜… í˜„ì¬ HPì— ë§ëŠ” ì™¸í˜•ìœ¼ë¡œ ê°±ì‹ 
local function setTreeVisual(model, cfg)
	
	local hp = model:GetAttribute("HP") or (cfg.MaxHP or 3)
	removeTreeVisual(model)

	-- í”„ë¦¬íŒ¹ ì œê³µì í•¨ìˆ˜ ì°¾ê¸°(ì—†ìœ¼ë©´ nil)
	local provider = cfg.VisualModels and cfg.VisualModels[hp]
	local prefab = provider and provider()

	local visual = model:FindFirstChild("Visual")
	if not visual then
		visual = Instance.new("Folder")
		visual.Name = "Visual"
		visual.Parent = model
	end

	if prefab and prefab:IsA("Model") then
		local cloned = prefab:Clone()
		cloned.Parent = visual
		placeOnTrunk(cloned, (model.PrimaryPart and model.PrimaryPart.CFrame) or model:GetPivot(), model.PrimaryPart)

	else
		-- í”„ë¦¬íŒ¹ì´ ì—†ì„ ë•Œ ì„ì‹œ ì‹œê°(HPì— ë”°ë¥¸ í¬ê¸°/ìƒ‰) ìƒì„±
		local p = Instance.new("Part")
		p.Name = "TreeHP"..hp
		p.Anchored = true
		p.CanCollide = false
		p.Size = Vector3.new(2 + hp*0.2, 6 + hp*0.5, 2 + hp*0.2)
		p.Color = Color3.fromHSV((0.35 + hp*0.1)%1, 0.5, 0.9)
		p.Parent = visual

		-- â˜… ë°”ë‹¥ ì •í™• ì •ë ¬(íŠ¸ë í¬ ë°”ë‹¥ = cf.Y - trunkHalf)
		local trunk = model.PrimaryPart
		local cf = trunk and trunk.CFrame or model:GetPivot()
		local trunkHalf = (trunk and trunk:IsA("BasePart")) and (trunk.Size.Y/2) or 0
		local trunkBottomY = cf.Position.Y - trunkHalf
		-- ì„ì‹œ íŒŒíŠ¸ì˜ ë°”ë‹¥ ì˜¤í”„ì…‹ì€ p.Size.Y/2 (Pivotê°€ ì¤‘ì•™)
		local targetPos = Vector3.new(cf.Position.X, trunkBottomY + (p.Size.Y/2), cf.Position.Z)
		local orientation = (cf - cf.Position)
		p.CFrame = CFrame.new(targetPos) * orientation
	end
	
	-- â˜… ì´ì „ì— ê·¸ë ¤ë‘” HPì™€ ë¹„êµí•´ì„œ FX ì¬ìƒ
	local prevShown = model:GetAttribute("LastHPVisual") or -1
	local newRoot = nil
	-- Visual í´ë”ì—ì„œ ì´ë²ˆì— ë°°ì¹˜ëœ ìµœìƒìœ„ ê°ì²´ë¥¼ ì°¾ì•„ë³¸ë‹¤(ëª¨ë¸ ë˜ëŠ” íŒŒíŠ¸)
	do
		local visual = model:FindFirstChild("Visual")
		if visual then
			newRoot = visual:FindFirstChildWhichIsA("Model") or visual:FindFirstChildWhichIsA("BasePart")
		end
	end
	if newRoot and prevShown ~= -1 and prevShown ~= hp then
		-- HPê°€ ì‹¤ì œë¡œ ë°”ë€ ìˆœê°„ì—ë§Œ FX
		playHPChangeFX(model, newRoot, prevShown, hp)
	end

	-- â˜… ì´ë²ˆì— ê·¸ë¦° HPë¥¼ ì €ì¥(ë‹¤ìŒ ë¹„êµìš©)
	model:SetAttribute("LastHPVisual", hp)
	
	-- â˜… ì–´ë–¤ ê²½ë¡œ(í”„ë¦¬íŒ¹/ì„ì‹œ)ë“  ì‹œê°ì€ ë°˜ë“œì‹œ ë³´ì´ê²Œ + TrunkëŠ” ìˆ¨ê¹€
	forceVisualVisible(model)
	setTrunkHidden(model, true)

end

-- Version 1.3.4: Mature ìƒíƒœì—ì„œë§Œ HP ë¹„ì£¼ì–¼ì„ ì ìš©í•˜ëŠ” ê°€ë“œ
local function setTreeVisualIfMature(model, cfg)
	if model:GetAttribute("TreeState") == "Mature" then
		setTreeVisual(model, cfg)
	end
end


-- â˜… ì„±ì¥ ë‹¨ê³„ ì™¸í˜• í‘œì‹œ: GrowthModels[stage] í”„ë¦¬íŒ¹ì„ íŠ¸ë í¬ ìœ„ì¹˜ì— ë°°ì¹˜
--    â–ª stage = 1..cfg.Growth.Stages
--    â–ª ì„±ëª©(ë§ˆì§€ë§‰ ë‹¨ê³„)ëŠ” HP3ê³¼ ë™ì¼ ë¹„ì£¼ì–¼ì„ ì“°ë©°, ì´ë• chop í—ˆìš©ìœ¼ë¡œ ì „í™˜í•œë‹¤.
-- Version 1.3.2: assign-form definition
setTreeGrowthVisual = function(model, cfg, stage)
	removeTreeVisual(model)

	local grow = cfg.Growth or {}
	local provider = grow.GrowthModels and grow.GrowthModels[stage]
	local prefab = provider and provider()

	local visual = model:FindFirstChild("Visual")
	if not visual then
		visual = Instance.new("Folder"); visual.Name="Visual"; visual.Parent=model
	end

	if prefab and prefab:IsA("Model") then
		local cloned = prefab:Clone(); cloned.Parent = visual
		placeOnTrunk(cloned, (model.PrimaryPart and model.PrimaryPart.CFrame) or model:GetPivot(), model.PrimaryPart)

	else
		-- í”„ë¦¬íŒ¹ ì—†ì„ ë•Œ ì„ì‹œ ì‹œê°(ë‹¨ê³„ë³„ í¬ê¸°/ìƒ‰)
		local p = Instance.new("Part")
		p.Name = "GrowStage"..tostring(stage)
		p.Anchored = true; p.CanCollide = false
		p.Size = Vector3.new(1.5+stage*0.5, 3+stage*1.0, 1.5+stage*0.5)
		p.Color = Color3.fromRGB(170, 220 - stage*20, 170)
		p.Parent = visual
		local trunk = model.PrimaryPart
		local cf = trunk and trunk.CFrame or model:GetPivot()
		local trunkHalf = (trunk and trunk:IsA("BasePart")) and (trunk.Size.Y/2) or 0
		local trunkBottomY = cf.Position.Y - trunkHalf
		-- ì„ì‹œ íŒŒíŠ¸ì˜ 'ë°”ë‹¥ ì˜¤í”„ì…‹'ì€ -p.Size.Y/2 (Pivotê°€ ì¤‘ì•™ì´ë¯€ë¡œ)
		local targetPos = Vector3.new(cf.Position.X, trunkBottomY + (p.Size.Y/2), cf.Position.Z)
		local orientation = (cf - cf.Position)
		p.CFrame = CFrame.new(targetPos) * orientation

	end
	
	-- (ì˜µì…˜) ì„±ì¥ ë‹¨ê³„ ì „í™˜ ì‹œì—ë„ ì/íŒŒí¸ ë²„ìŠ¤íŠ¸
	do
		local trunkCF = (model.PrimaryPart and model.PrimaryPart.CFrame) or model:GetPivot()
		EffectLib.EmitBurstAt(trunkCF * CFrame.new(0, 1.0, 0), nil, 10)
	end
	
	-- â˜… ì–´ë–¤ ê²½ë¡œë¡œ ìƒì„±ëë“ , ë‹¨ê³„ í‘œì‹œê°€ ëë‚˜ë©´ 'ë¬´ì¡°ê±´' ë³´ì´ê²Œ ê³ ì •
	forceVisualVisible(model)
end

-- â˜… ì„±ì¥ ì‹œì‘/ì§„í–‰: TreeState="Growing", GrowthStage=1..N
local function startGrowthCycle(model, cfg)
	local grow = cfg.Growth
	if not grow or not grow.Stages or grow.Stages < 1 then
		model:SetAttribute("TreeState", "Mature")
		model:SetAttribute("HP", cfg.MaxHP)
		model:SetAttribute("IsFelled", false)
		setTreeVisual(model, cfg)
		ensureChopPrompt(model, cfg)
		return
	end

	model:SetAttribute("TreeState", "Growing")
	model:SetAttribute("GrowthStage", 1)
	setModelVisible(model, true)                 -- â˜… í•­ìƒ ë³´ì´ê²Œ
	setTreeGrowthVisual(model, cfg, 1)
	removeChopPrompt(model)                      -- ì„±ì¥ ì¤‘ ë² ê¸° ê¸ˆì§€
	-- â˜… ì„±ì¥ ì´ˆê¸°: TrunkëŠ” ì ˆëŒ€ ë³´ì´ì§€ ì•Šê²Œ
	setTrunkHidden(model, true)	

	local function advance(stage)
		if not model or not model.Parent then return end
		local maxStage = grow.Stages
		if stage >= maxStage then
			--â˜…ì„±ëª© ë„ë‹¬ ë¶„ê¸°
			model:SetAttribute("TreeState", "Mature")
			model:SetAttribute("GrowthStage", maxStage)
			model:SetAttribute("MaxHP", cfg.MaxHP or 3)   -- â˜… UIìš© ìµœëŒ€ì²´ë ¥ ë³´ì¥
			model:SetAttribute("HP", cfg.MaxHP or 3)
			setModelVisible(model, true)
			setTreeVisual(model, cfg)
			ensureChopPrompt(model, cfg)

			return
		end


		local delaySec = grow.StageDuration and grow.StageDuration[stage] or 20
		task.delay(delaySec, function()
			if not model or not model.Parent then return end
			local current = (model:GetAttribute("GrowthStage") or 1)
			if current ~= stage then return end

			local nextStage = stage + 1
			model:SetAttribute("GrowthStage", stage+1)

			setModelVisible(model, true)         -- â˜… ë‹¨ê³„ ì „í™˜ ë•Œë§ˆë‹¤ ê°€ì‹œí™” ë³´ì¥
			-- â˜… TrunkëŠ” í•­ìƒ ìˆ¨ê¹€(ê°€ë¦¼ ë°©ì§€)
			setTrunkHidden(model, true)
			setTreeGrowthVisual(model, cfg, stage+1)

			print(("[ResourceService v1.4.2] %s Growth %d -> %d")
				:format(model.Name, stage, stage+1))

			advance(nextStage)
		end)
	end

	advance(1)
end



ensureChopPrompt = function(model, cfg)
	removeChopPrompt(model)
	local attach = model.PrimaryPart or model

	local pp = Instance.new("ProximityPrompt")
	pp.Name = "ChopPrompt"
	pp.ActionText = "ë²Œëª©"
	pp.ObjectText = "ë‚˜ë¬´"
	pp.KeyboardKeyCode = Enum.KeyCode.E
	pp.GamepadKeyCode = Enum.KeyCode.ButtonX
	pp.HoldDuration = cfg.HitHold or 0.8
	pp.MaxActivationDistance = cfg.MaxDistance or 12
	pp.RequiresLineOfSight = false
	pp.Style = Enum.ProximityPromptStyle.Default
	pp.Exclusivity = Enum.ProximityPromptExclusivity.OnePerButton
	pp.ClickablePrompt = false   -- âœ… Eí‚¤ ì „ìš© (í´ë¦­/í„°ì¹˜ ë¹„í™œì„±)
	pp.Parent = attach

	-- íŠ¸ë¦¬ê±° ì—°ê²°
	pp.Triggered:Connect(function(player)
		-- 1) íˆ´ ê²€ì¦: Axe ì¥ì°© ì¤‘?
		local char = player.Character
		local tool = char and char:FindFirstChildOfClass("Tool")
		local requireName = cfg.RequireToolName or "Axe"
		if not tool or tool.Name ~= requireName then
			-- (ì„ íƒ) ë‚˜ì¤‘ì— UIë¡œ "ë„ë¼ í•„ìš”" ì•ˆë‚´ ê°€ëŠ¥
			return
		end
		
		if model:GetAttribute("TreeState") == "Growing" then return end

		-- 2) ì´ë¯¸ ë² ì–´ì§„ ë‚˜ë¬´ë©´ ë¬´ì‹œ
		if model:GetAttribute("IsFelled") then return end

		-- 3) HP ì°¨ê°
		local hp = model:GetAttribute("HP") or cfg.MaxHP
		hp -= 1
		if hp < 0 then hp = 0 end
		model:SetAttribute("HP", hp)
		
		-- â˜… íƒ€ê²© ì§í›„ ì™¸í˜• ê°±ì‹  (HP3â†’HP2â†’HP1)
		if hp > 0 then
			setTreeVisualIfMature(model, cfg)
		end

		-- Version 1.3.3
		-- ë² ì–´ì§ ì²˜ë¦¬ (ì• ë‹ˆ + ì„±ì¥ ì „í™˜)
		if hp <= 0 then
			model:SetAttribute("IsFelled", true)
			model:SetAttribute("TreeState", "Felled")  -- â˜… ë² ì–´ì§„ ì¦‰ì‹œ ìƒíƒœ ê³ ì •
			removeChopPrompt(model)

			local reward = cfg.Reward or { ToolName = "Wood", Amount = 1 }
			ItemService.GiveItem(player, reward.ToolName or "Wood", reward.Amount or 1)
			
			---- â˜… Wood ì¸ë²¤í† ë¦¬ ì§€ê¸‰ + í”½ì—… ì•Œë¦¼(í´ë¼ HUD)
			--local rewardWood = (cfg and cfg.Reward and cfg.Reward.Wood) or 1  -- ê¸°ë³¸ 1
			--local inv = ensureInventory(player)
			--local wood = ensureItem(inv, "Wood")
			--wood.Value += rewardWood
			
			-- â˜… í”½ì—… í† ìŠ¤íŠ¸(í´ë¼ HUD) ì „ì†¡: ì•„ì´ì½˜ + "+ìˆ˜ëŸ‰"
			evPicked:FireClient(player, {
				id  = reward.ToolName or "Wood",
				qty = reward.Amount or 1
			})

			playFellAnimation(model, player, 0.65)

			-- â˜… ì“°ëŸ¬ì§„ ë’¤ Grow1ë¡œ ì „í™˜ê¹Œì§€ì˜ ëŒ€ê¸°ì‹œê°„: StumpSeconds ìš°ì„ , ì—†ìœ¼ë©´ RespawnSeconds
			local delayToGrow = (cfg.StumpSeconds ~= nil) and cfg.StumpSeconds or (cfg.RespawnSeconds or 0)

			task.delay(delayToGrow, function()
				if not model or not model.Parent then return end
				model:SetAttribute("IsFelled", false)   -- ì„±ì¥ ì‹œì‘ ì „ ìƒíƒœ í”Œë˜ê·¸ í•´ì œ
				-- âœ… ì„±ì¥ ì‚¬ì´í´ ì‹œì‘: Grow1 í‘œì‹œ + íƒ€ì´ë¨¸ ì˜ˆì•½(Grow2â†’ì„±ëª©)ê¹Œì§€ ìë™ ìˆ˜í–‰
				startGrowthCycle(model, cfg)
			end)


		end


	end)
end

-- â˜… ì„±ì¥/ìƒíƒœ ë³€ê²½ ê°ì‹œ: í‘œì‹œê°€ ì–´ê¸‹ë‚˜ë©´ ì¦‰ì‹œ ì¬ë„ìƒ‰/í”„ë¡¬í”„íŠ¸ ë³µêµ¬
local function attachGrowthWatchers(model, cfg)
	-- GrowthStageê°€ ë³€í•˜ë©´ í•´ë‹¹ ë‹¨ê³„ ì™¸í˜•ìœ¼ë¡œ ì¬ì ìš©
	model:GetAttributeChangedSignal("GrowthStage"):Connect(function()
		if model:GetAttribute("TreeState") == "Growing" then
			local stage = model:GetAttribute("GrowthStage") or 1
			setModelVisible(model, true)                 -- í˜¹ì‹œ ë‚¨ì€ íˆ¬ëª… ë³µêµ¬
			setTreeGrowthVisual(model, cfg, stage)
		end
	end)

	-- TreeStateê°€ ë³€í•˜ë©´ ìƒíƒœì— ë§ì¶° ë³µêµ¬
	model:GetAttributeChangedSignal("TreeState"):Connect(function()
		local state = model:GetAttribute("TreeState")
		if state == "Mature" then
			setModelVisible(model, true)
			setTreeVisual(model, cfg)
			setTrunkHidden(model, true)       -- â˜… í•­ìƒ ìˆ¨ê¹€ ìœ ì§€
			ensureChopPrompt(model, cfg)
		elseif state == "Growing" then
			removeChopPrompt(model)
			local stage = model:GetAttribute("GrowthStage") or 1
			setModelVisible(model, true)
			setTreeGrowthVisual(model, cfg, stage)
			setTrunkHidden(model, true)       -- â˜… í•­ìƒ ìˆ¨ê¹€ ìœ ì§€
		end
	end)
end



-- ë‚˜ë¬´ ì´ˆê¸°í™” (Attribute/HP ë³´ì¥ + í”„ë¡¬í”„íŠ¸ ë¶€ì°©)
local function initTree(model)
	local nodeType = model:GetAttribute("NodeType") or "Tree"
	model:SetAttribute("NodeType", nodeType)
	local cfg = ResourceConfig:GetNode(nodeType)
	if not cfg then
		warn(("[ResourceService v1.1a] ë¯¸ì§€ì› NodeType: %s (%s)"):format(tostring(nodeType), model.Name))
		return
	end
	if not model.PrimaryPart then
		warn(("[ResourceService v1.1a] PrimaryPart(Trunk) ë¯¸ì§€ì •: %s"):format(model.Name))
		return
	end

	local maxHp = cfg.MaxHP or 3
	if model:GetAttribute("MaxHP") == nil then model:SetAttribute("MaxHP", maxHp) end
	if model:GetAttribute("HP") == nil then model:SetAttribute("HP", maxHp) end
	if model:GetAttribute("IsFelled") == nil then model:SetAttribute("IsFelled", false) end

	-- â˜… 1) ì›ë˜ íŠ¸ë¦¬ ì‹œê° íŒŒì¸  ê²©ë¦¬/ìˆ¨ê¹€
	quarantineOriginalVisual(model)
	-- Visual í´ë” ì¡´ì¬ ë³´ì¥(ì—†ìœ¼ë©´ ìƒì„±)
	if not model:FindFirstChild("Visual") then
		local v = Instance.new("Folder")
		v.Name = "Visual"
		v.Parent = model
	end
	-- ê¸°ì¤€ íŒŒíŠ¸ëŠ” ìˆ¨ê¹€ ìœ ì§€(ê²‰ëª¨ìŠµì€ Visualë§Œ ë‹´ë‹¹)
	setTrunkHidden(model, true)

	-- â˜… TrunkëŠ” í•­ìƒ ìˆ¨ê¹€(Visualì´ ì™¸í˜• ë‹´ë‹¹)
	setTrunkHidden(model, true)
	
	-- â˜… 1.5) ì„±ì¥/ìƒíƒœ ê°ì‹œ Watcher ë¶€ì°© (ì–¸ì œë“  ì¦‰ì‹œ ë³µêµ¬)
	attachGrowthWatchers(model, cfg)

	-- â˜… 2) ìƒíƒœì— ë”°ë¼ ë³µêµ¬
	local state = model:GetAttribute("TreeState")
	if state == "Growing" then
		-- ì„±ì¥ ì¤‘ì¸ ê²½ìš°: ì €ì¥ëœ ë‹¨ê³„ë¡œ ì™¸í˜• ë³µêµ¬ + ìŠ¤ì¼€ì¤„ ì´ì–´ì„œ ì§„í–‰
		local stage = model:GetAttribute("GrowthStage") or 1
		setModelVisible(model, true)
		setTreeGrowthVisual(model, cfg, stage)
		removeChopPrompt(model)
		-- ì´ì–´ì„œ ì„±ì¥
		local grow = cfg.Growth
		if grow and stage < (grow.Stages or 1) then
			-- ê°„ë‹¨: í˜„ì¬ ë‹¨ê³„ë¶€í„° ë‹¤ì‹œ ìŠ¤ì¼€ì¤„
			task.defer(function()
				startGrowthCycle(model, cfg)
			end)
		end
	else
		-- ê¸°ë³¸: ì„±ëª© ìƒíƒœ(ë² ê¸° í—ˆìš©)
		model:SetAttribute("TreeState", "Mature")
		model:SetAttribute("HP", model:GetAttribute("HP") or (cfg.MaxHP or 3))
		setTreeVisual(model, cfg)
		ensureChopPrompt(model, cfg)
	end
end


-- ì„œë²„ ì‹œì‘ ì‹œ Trees í´ë” ìŠ¤ìº”
for _, m in ipairs(TreesFolder:GetChildren()) do
	if m:IsA("Model") then
		initTree(m)
	end
end
-- ì´í›„ ì¶”ê°€ë˜ëŠ” ë‚˜ë¬´ë„ ì§€ì›
TreesFolder.ChildAdded:Connect(function(m)
	if m:IsA("Model") then
		-- PrimaryPart ì„¸íŒ…ì´ ëŠë¦¬ê²Œ ë  ìˆ˜ ìˆìœ¼ë‹ˆ ì•½ê°„ ëŒ€ê¸°
		task.defer(function()
			if not m.PrimaryPart then m:GetPropertyChangedSignal("PrimaryPart"):Wait() end
			initTree(m)
		end)
	end
end)
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Script" referent="RBXC98ACCF7D4444857BE12119689DC9F6F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">ShopService</string>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{D30B2735-31C7-4757-B5EE-9A52E22062B9}</string>
			<ProtectedString name="Source"><![CDATA[-- Version v1.2
-- ShopService: ìƒì  ì„œë²„ ë¡œì§ (ê²€ì¦/ì½”ì¸ ì¦ê°/ì¸ë²¤í† ë¦¬ ì¦ê°)
-- ì•ˆì „ì„¤ëª…:
-- - RemoteFunction(Buy/Sell)ìœ¼ë¡œë§Œ ê±°ë˜. ì„œë²„ê°€ 'ìµœì¢… ê²€ì¦'ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
-- - ì¸ë²¤í† ë¦¬ëŠ” Player.Inventory(IntValueë“¤)ë¡œ ê°„ë‹¨ ì €ì¥. ê¸°ì¡´ì— ìˆìœ¼ë©´ ì¬ì‚¬ìš©.

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players           = game:GetService("Players")

local Config = require(ReplicatedStorage.Shared.ShopConfig)

-- â˜… Remotes/Shop í´ë” ë³´ì¥
local remotes = ReplicatedStorage:FindFirstChild("Remotes") or Instance.new("Folder", ReplicatedStorage)
remotes.Name = "Remotes"
local shopFolder = remotes:FindFirstChild("Shop") or Instance.new("Folder", remotes)
shopFolder.Name = "Shop"
-- RemoteEventë¡œ ì¼ì›í™” (í´ë¼ :FireServer() ì„¤ê³„ì™€ ì¼ì¹˜)
local evBuy  = shopFolder:FindFirstChild("Buy")
if not evBuy then
	evBuy = Instance.new("RemoteEvent")
	evBuy.Name = "Buy"
	evBuy.Parent = shopFolder
end

local evSell = shopFolder:FindFirstChild("Sell")
if not evSell then
	evSell = Instance.new("RemoteEvent")
	evSell.Name = "Sell"
	evSell.Parent = shopFolder
end


-- í´ë”ëª…ì€ Config.InventoryFolderNameê°€ ìˆìœ¼ë©´ ê·¸ê±¸ ë”°ë¥´ê³ , ì—†ìœ¼ë©´ "Inventory"
local function ensureInventory(plr: Player): Folder
	local name = (Config and Config.InventoryFolderName) or "Inventory"
	local f = plr:FindFirstChild(name)
	if not f then
		f = Instance.new("Folder")
		f.Name = name
		f.Parent = plr
	end
	return f
end


local function ensureItem(inv: Folder, id: string): IntValue
	local v = inv:FindFirstChild(id)
	if not v then
		v = Instance.new("IntValue")
		v.Name = id
		v.Value = 0
		v.Parent = inv
	end
	return v
end


-- ìœ„ ensure* ë¥¼ ë‹¨ì¼ ì§„ì…ì ìœ¼ë¡œ ì‚¬ìš© (ì´ì¤‘ ìƒì„± ë°©ì§€)
local function getInventory(player: Player)
	return ensureInventory(player)
end

local function getItemValue(inv: Folder, id: string)
	return ensureItem(inv, id)
end


local function findItem(id)
	for _, it in ipairs(Config.Items) do
		if it.id == id then return it end
	end
	return nil
end

-- í”Œë ˆì´ì–´ ì½”ì¸ ë³´ì¥
local function ensureCoinsAttr(plr: Player)
	if plr:GetAttribute(Config.CurrencyName) == nil then
		plr:SetAttribute(Config.CurrencyName, 100) -- ì‹œì‘ ì½”ì¸ 0 (í•„ìš”ì‹œ ë°”ê¾¸ì„¸ìš”)
	end
end

Players.PlayerAdded:Connect(function(plr)
	ensureCoinsAttr(plr)
	-- v1.2: ì¸ë²¤í† ë¦¬ í´ë”ë§Œ ë³´ì¥(í•­ëª©ì€ êµ¬ë§¤/íŒë§¤ ì‹œ ìë™ ìƒì„±)
	ensureInventory(plr)
	getInventory(plr) -- í´ë”ë§Œ ë³´ì¥
end)

-- ê³µí†µ ì‘ë‹µí˜•ì‹
local function ok(tbl) tbl.ok = true; return tbl end
local function fail(msg) return { ok=false, error=msg } end

-- êµ¬ë§¤ ì²˜ë¦¬
-- RemoteEventëŠ” ë°˜í™˜ê°’ì´ ì—†ìœ¼ë¯€ë¡œ Connect ì‚¬ìš©
evBuy.OnServerEvent:Connect(function(plr: Player, id: string, qty: number?)
	ensureCoinsAttr(plr)
	qty = math.clamp(tonumber(qty) or 1, 1, 999)

	local def = findItem(id)
	if not def or not def.buy then
		return -- êµ¬ë§¤ ë¶ˆê°€ í’ˆëª©
	end

	local price = def.buy * qty
	local coins = plr:GetAttribute(Config.CurrencyName) or 0
	if coins < price then
		return -- ì½”ì¸ ë¶€ì¡±
	end

	-- ì¸ë²¤í† ë¦¬ ì¦ê°€: ì •í™•íˆ qtyë§Œí¼ ë”± 1íšŒ ì¦ê°€
	local inv = ensureInventory(plr)
	local counter = ensureItem(inv, id)
	counter.Value += qty

	-- ì½”ì¸ ì°¨ê°
	plr:SetAttribute(Config.CurrencyName, coins - price)
end)


-- íŒë§¤ ì²˜ë¦¬
evSell.OnServerEvent:Connect(function(plr: Player, id: string, qty: number?)
	ensureCoinsAttr(plr)
	qty = math.clamp(tonumber(qty) or 1, 1, 999)

	local def = findItem(id)
	if not def or not def.sell then
		return -- íŒë§¤ ë¶ˆê°€ í’ˆëª©
	end

	local inv = getInventory(plr)
	local v = getItemValue(inv, id)
	if v.Value < qty then
		return -- ìˆ˜ëŸ‰ ë¶€ì¡±
	end

	v.Value -= qty
	local coins = (plr:GetAttribute(Config.CurrencyName) or 0) + (def.sell * qty)
	plr:SetAttribute(Config.CurrencyName, coins)
end)

]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ModuleScript" referent="RBX0CBB45D6CDFF4544BD5C891A69DBE923">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">ItemService</string>
			<string name="ScriptGuid">{6F622B50-9626-4876-8353-267D327DE7E6}</string>
			<ProtectedString name="Source"><![CDATA[-- Version 1.1
--[[
  ItemService: ìˆ˜í™•/ë³´ìƒ ë“±ìœ¼ë¡œ "íˆ´"ì„ í”Œë ˆì´ì–´ì—ê²Œ ì§€ê¸‰í•˜ê³ , ê°™ì€ ì•„ì´í…œì´ë©´ Backpackì—ì„œ ìŠ¤íƒí•©ë‹ˆë‹¤.
  â–ª ReplicatedStorage/Tools/Produce/<ToolName> í…œí”Œë¦¿ì„ ìš°ì„  ì°¾ìŒ
  â–ª ì—†ìœ¼ë©´ ReplicatedStorage/Tools/<ToolName>ì—ì„œë„ ì‹œë„
  â–ª ê·¸ë˜ë„ ì—†ìœ¼ë©´ RequiresHandle=false ë¹ˆ íˆ´ì„ ì¦‰ì„ ìƒì„±(ì•ˆì „ì¥ì¹˜)
--]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local ItemService = {}

local function findTemplate(toolName)
	local tools = ReplicatedStorage:FindFirstChild("Tools")
	if not tools then return nil end
	local produce = tools:FindFirstChild("Produce")
	if produce then
		local t = produce:FindFirstChild(toolName)
		if t and t:IsA("Tool") then return t end
	end
	local t2 = tools:FindFirstChild(toolName)
	if t2 and t2:IsA("Tool") then return t2 end
	return nil
end

local function ensureMeta(tool, canonicalId)
	local amount = tool:FindFirstChild("Amount")
	if not amount then
		amount = Instance.new("IntValue")
		amount.Name = "Amount"
		amount.Value = 1
		amount.Parent = tool
	end
	local itemId = tool:FindFirstChild("ItemId")
	if not itemId then
		itemId = Instance.new("StringValue")
		itemId.Name = "ItemId"
		itemId.Value = canonicalId or tool.Name
		itemId.Parent = tool
	else
		if canonicalId and itemId.Value ~= canonicalId then
			itemId.Value = canonicalId
		end
	end
end

-- ê°™ì€ ì•„ì´í…œ íŒë‹¨(ì´ë¦„ì´ 'Tomato xN'ì´ì–´ë„ true)
local function isSameItem(tool, toolName)
	local id = tool:FindFirstChild("ItemId")
	if id and id:IsA("StringValue") and id.Value == toolName then
		return true
	end
	if tool.Name == toolName then return true end
	if string.match(tool.Name, "^" .. toolName .. " x%d+$") then
		return true
	end
	return false
end

-- Backpack + Characterì—ì„œ ëª¨ë‘ ìˆ˜ì§‘
local function collectPlayerTools(player)
	local list = {}
	local bp = player:FindFirstChild("Backpack")
	if bp then
		for _, t in ipairs(bp:GetChildren()) do
			if t:IsA("Tool") then table.insert(list, t) end
		end
	end
	local char = player.Character
	if char then
		for _, t in ipairs(char:GetChildren()) do
			if t:IsA("Tool") then table.insert(list, t) end
		end
	end
	return list
end

-- ì¤‘ë³µ ë³‘í•©: target í•˜ë‚˜ë¥¼ ì •í•˜ê³  ê°™ì€ ì•„ì´í…œë“¤ì„ ëª¨ë‘ í•©ì¹¨
local function mergeAllInto(target, others, toolName)
	ensureMeta(target, toolName)
	local total = target.Amount.Value
	for _, t in ipairs(others) do
		if t ~= target and isSameItem(t, toolName) then
			ensureMeta(t, toolName)
			total += (t.Amount and t.Amount.Value or 1)
			t:Destroy()
		end
	end
	target.Amount.Value = total
	target.Name = ("%s x%d"):format(toolName, total)
	return target
end

function ItemService.GiveItem(player, toolName, addAmount)
	addAmount = tonumber(addAmount) or 1

	-- 1) ë‚´ ëª¨ë“  íˆ´ ìˆ˜ì§‘(Backpack + Character)
	local all = collectPlayerTools(player)

	-- 2) ê°™ì€ ì•„ì´í…œ ëª©ë¡ í•„í„°
	local same = {}
	for _, t in ipairs(all) do
		if isSameItem(t, toolName) then
			table.insert(same, t)
		end
	end

	-- 3) íƒ€ê²Ÿ ê²°ì •: ìºë¦­í„°ì— ë“¤ê³  ìˆëŠ”ê²Œ ìˆìœ¼ë©´ ê·¸ê±¸ ìš°ì„ , ì—†ìœ¼ë©´ ì•„ë¬´ê±°ë‚˜
	local target = nil
	for _, t in ipairs(same) do
		if t.Parent == (player.Character or t.Parent) then
			target = t; break
		end
	end
	if not target then target = same[1] end

	-- 4) ì¡´ì¬í•˜ë©´ ë³‘í•© + ìˆ˜ëŸ‰ ì¦ê°€
	if target then
		target = mergeAllInto(target, same, toolName)
		target.Amount.Value += addAmount
		target.Name = ("%s x%d"):format(toolName, target.Amount.Value)
		return true, "Stacked"
	end

	-- 5) ì•„ì˜ˆ ì—†ìœ¼ë©´ ìƒˆë¡œ ì§€ê¸‰(Backpackì—)
	local backpack = player:FindFirstChild("Backpack")
	if not backpack then return false, "NoBackpack" end

	local tpl = findTemplate(toolName)
	local tool
	if tpl then
		tool = tpl:Clone()
	else
		tool = Instance.new("Tool")
		tool.Name = toolName
		tool.RequiresHandle = false
	end
	tool.Parent = backpack

	ensureMeta(tool, toolName)
	tool.Amount.Value = addAmount
	tool.Name = ("%s x%d"):format(toolName, tool.Amount.Value)

	return true, "Granted"
end

return ItemService]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ModuleScript" referent="RBXF9AA36BE65B44CFF9B7B7358DD70A319">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">PlotAssignmentHandler</string>
			<string name="ScriptGuid">{CC351A56-05F0-4E6B-BE99-A7A79DA1ECDF}</string>
			<ProtectedString name="Source"><![CDATA[-- Version 1.4a
--[[
  ëª¨ë“ˆ ì—­í• (ì´ˆë³´ì ì¹œì ˆ ì„¤ëª…):
  - "ë°­ ë°°ì •/í•´ì œ/ì†Œìœ ê¶Œ í™•ì¸"ì„ ë‹´ë‹¹í•˜ëŠ” **ì„œë²„ ì „ìš© ëª¨ë“ˆ**ì…ë‹ˆë‹¤.
  - v1.4aì—ì„œëŠ” Scriptê°€ ì•„ë‹ˆë¼ **ModuleScript**ë¡œ ë³€ê²½ë˜ì–´
    ë‹¤ë¥¸ ì„œë²„ ìŠ¤í¬ë¦½íŠ¸(ì˜ˆ: PlantService)ê°€ requireë¡œ ì•ˆì „í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

  ë™ì‘ ê°œìš”:
  1) Init()ì—ì„œ Workspace/Plotsë¥¼ ìŠ¤ìº” â†’ PlotId í‘œì¤€í™” â†’ ì •ë ¬(plotOrder: Plot1â†’Plot2â†’â€¦)
  2) PlayerAdded/Removing ì—°ê²°, ë¹ˆ ë°­(false) â†’ ì†Œìœ ì(UserId)ë¡œ ì—…ë°ì´íŠ¸
  3) IsOwner(player, plotModel)ë¡œ ì†Œìœ ê¶Œ ê²€ì‚¬ ì œê³µ (ì‹¬ê¸°/ìˆ˜í™• ë“±ì—ì„œ í˜¸ì¶œ)

  ìš©ì–´ ì •ë¦¬:
  - PrimaryPart: Modelì˜ ëŒ€í‘œ íŒŒíŠ¸(ë³´í†µ Base). ë°˜ë“œì‹œ ì§€ì •!
  - Attribute: ê°ì²´ì— ë‹¤ëŠ” ë°ì´í„° ë¼ë²¨. ì—¬ê¸°ì„œëŠ” "PlotId" ë¬¸ìì—´ ì‚¬ìš©.

  ì‚¬ìš©ë²•:
  - ë‹¤ë¥¸ ìŠ¤í¬ë¦½íŠ¸ì—ì„œ `local Plot = require(ServerScriptService.PlotAssignmentHandler)`
  - ì„œë²„ ì‹œì‘ ì‹œ `Plot.Init()`ë¥¼ í•œ ë²ˆ í˜¸ì¶œ(ë¶€íŠ¸ìŠ¤í¬ë¦½íŠ¸ê°€ í˜¸ì¶œ)
  - ì†Œìœ ê¶Œ ê²€ì‚¬: `Plot.IsOwner(player, plotModel)`
--]]

local Players = game:GetService("Players")
local PlotsFolder = workspace:WaitForChild("Plots")

-- ë‚´ë¶€ ìƒíƒœ
local assignedPlots = {}   -- [PlotId] = false(ë¹ˆ ë°­) ë˜ëŠ” UserId(ì†Œìœ ì)
local playerPlots   = {}   -- [UserId] = PlotId
local plotOrder     = {}   -- Plot Model ëª©ë¡(Plot1â†’Plot2â†’â€¦ ì •ë ¬)
local initialized   = false

-- ìœ í‹¸: ì´ë¦„ì—ì„œ ìˆ«ì ì¶”ì¶œ ("Plot12" â†’ 12, ì—†ìœ¼ë©´ math.hugeë¡œ ë§¨ ë’¤)
local function extractPlotNumber(name)
	local num = string.match(name, "%d+")
	return tonumber(num) or math.huge
end

-- ìœ í‹¸: ëª¨ë¸ ì´ë¦„ì„ ìˆ«ì ì˜¤ë¦„ì°¨ìˆœ(ë³´ì¡° ì•ŒíŒŒë²³)ìœ¼ë¡œ ì •ë ¬
local function sortPlotsByName(a, b)
	local na = extractPlotNumber(a.Name)
	local nb = extractPlotNumber(b.Name)
	if na == nb then
		return a.Name < b.Name
	end
	return na < nb
end

-- ë‚´ë¶€: Plots ìŠ¤ìº” + í‘œì¤€í™” + ì •ë ¬
local function scanAndOrderPlots()
	assignedPlots = {}
	plotOrder = {}
	for _, plot in ipairs(PlotsFolder:GetChildren()) do
		if plot:IsA("Model") then
			if not plot.PrimaryPart then
				warn(("[PlotAssignmentHandler v1.4a] PrimaryPart ì—†ìŒ: %s (ë³´í†µ 'Base'ë¥¼ ì§€ì •í•˜ì„¸ìš”)"):format(plot.Name))
			else
				-- Modelì— PlotIdê°€ ìˆëŠ”ì§€ ìš°ì„  í™•ì¸
				local plotId = plot:GetAttribute("PlotId")
				-- ì—†ìœ¼ë©´ PrimaryPartì˜ PlotIdë¥¼ ëŒì–´ì™€ì„œ Modelì— ìŠ¹ê²©
				if not plotId and plot.PrimaryPart then
					plotId = plot.PrimaryPart:GetAttribute("PlotId")
					if plotId then
						plot:SetAttribute("PlotId", plotId)
						print(("[PlotAssignmentHandler v1.4a] %s: PrimaryPartì˜ PlotIdë¥¼ Modelë¡œ ìŠ¹ê²©: %s"):format(plot.Name, plotId))
					end
				end
				-- ê·¸ë˜ë„ ì—†ìœ¼ë©´ Model.Nameìœ¼ë¡œ ìë™ ì„¤ì •(ì•ˆì „ì¥ì¹˜)
				if not plotId then
					plotId = plot.Name
					plot:SetAttribute("PlotId", plotId)
					warn(("[PlotAssignmentHandler v1.4a] %s: PlotId ë¯¸ì„¤ì • â†’ Model.Name(%s)ë¡œ ìë™ ì„¤ì •"):format(plot.Name, plotId))
				end

				assignedPlots[plotId] = assignedPlots[plotId] == true and assignedPlots[plotId] or false
				table.insert(plotOrder, plot)

				print(("[PlotAssignmentHandler v1.4a] ìŠ¤ìº”ë¨: %s (PlotId=%s)"):format(plot.Name, plotId))
			end
		end
	end
	table.sort(plotOrder, sortPlotsByName)
end

-- ë‚´ë¶€: ìˆœì„œëŒ€ë¡œ ë¹ˆ ë°­ ë°°ì •
local function assignPlotToPlayer(player)
	for _, plotModel in ipairs(plotOrder) do
		local plotId = plotModel:GetAttribute("PlotId") or plotModel.Name
		local ownerId = assignedPlots[plotId]
		if ownerId == false then
			assignedPlots[plotId] = player.UserId
			playerPlots[player.UserId] = plotId
			print(("[PlotAssignmentHandler v1.4a] %së‹˜ì´ %s ë°­ì„ ë°°ì •ë°›ì•˜ìŠµë‹ˆë‹¤."):format(player.Name, plotId))
			return
		end
	end
	warn(("[PlotAssignmentHandler v1.4a] ë°°ì • ì‹¤íŒ¨: ë¹ˆ ë°­ì´ ì—†ìŠµë‹ˆë‹¤ (í”Œë ˆì´ì–´=%s)"):format(player.Name))
end

-- ë‚´ë¶€: ë°­ ë¹„ìš°ê¸°
local function removePlayerPlot(player)
	local plotId = playerPlots[player.UserId]
	if plotId then
		assignedPlots[plotId] = false
		playerPlots[player.UserId] = nil
		print(("[PlotAssignmentHandler v1.4a] %së‹˜ì˜ %s ë°­ì´ ë¹„ì›Œì¡ŒìŠµë‹ˆë‹¤."):format(player.Name, plotId))
	end
end

-- ê³µê°œ API: ì†Œìœ ê¶Œ ê²€ì‚¬
local function isOwner(player, plotModel)
	if not plotModel or not plotModel:IsA("Model") then return false end
	local plotId = plotModel:GetAttribute("PlotId")
	if not plotId and plotModel.PrimaryPart then
		plotId = plotModel.PrimaryPart:GetAttribute("PlotId")
	end
	if not plotId then return false end
	return assignedPlots[plotId] == player.UserId
end

-- ê³µê°œ API: ì´ˆê¸°í™”(í•œ ë²ˆë§Œ)
local function init()
	if initialized then return end
	initialized = true

	scanAndOrderPlots()

	-- ì´ë²¤íŠ¸ ì—°ê²°
	Players.PlayerAdded:Connect(assignPlotToPlayer)
	Players.PlayerRemoving:Connect(removePlayerPlot)

	-- ì´ë¯¸ ì ‘ì† ì¤‘ì¸ í”Œë ˆì´ì–´ ì²˜ë¦¬(Studio í¸ì˜)
	for _, p in ipairs(Players:GetPlayers()) do
		assignPlotToPlayer(p)
	end
end

-- ëª¨ë“ˆ í…Œì´ë¸” ë°˜í™˜
return {
	Init = init,        -- ë°˜ë“œì‹œ ì„œë²„ì—ì„œ 1íšŒ í˜¸ì¶œ(ë¶€íŠ¸ìŠ¤í¬ë¦½íŠ¸ê°€ í˜¸ì¶œ)
	IsOwner = isOwner,  -- ì„œë²„ì˜ ë‹¤ë¥¸ ìŠ¤í¬ë¦½íŠ¸(ì˜ˆ: PlantService)ì—ì„œ ì‚¬ìš©
}
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
</roblox>