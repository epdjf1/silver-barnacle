<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="LocalScript" referent="RBX799E050FD7474A7BB1660E8E89BFF096">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">HotbarClient</string>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{C507E13D-5E0B-4D44-A1DF-99E9CB02DE91}</string>
			<ProtectedString name="Source"><![CDATA[-- Version 1.8.0
-- HotbarClient (안정판)
-- 목적(초보 친화 설명):
--  1) 플레이어 인벤토리(LocalPlayer/Inventory : IntValue 집합)와 ReplicatedStorage/Tools의 Tool 프리팹을 읽어
--     하단 단축바(핫바)를 자동 생성/갱신합니다.
--  2) 마우스 클릭과 **상단 숫자키(1~8)** 로 슬롯 선택이 가능합니다. (키패드 사용 안 함)
--     - Tool 계열(도끼, 씨앗 등)은 수량이 0이라도 장착 가능(게임 규칙에 따라 장착만).
--     - 비장착 아이템(예: Wood)은 선택/하이라이트만 하고 실제 착용은 하지 않습니다.
--  3) "첫 슬롯만 장착" 문제를 방지하기 위해
--     - 반복문 클로저 캡처 주의(로컬 복사),
--     - 화면 순서(order) 기반 인덱싱 고정,
--     - ContextActionService 우선순위 상향 + 폴백(InputBegan) 처리,
--     - 리스폰(CharacterAdded) 시 자동 재바인딩 을 적용했습니다.
--
-- 용어 풀이:
--  - Inventory(IntValue): 각 아이템 이름(예: "TomatoSeed")을 가진 IntValue. 수량을 나타냅니다.
--  - Tools 폴더: ReplicatedStorage.Tools 밑 Tool 프리팹(장착 가능한 아이템).
--  - ItemDefs 모듈(있으면 사용): 아이템에 대한 정의 테이블 { equip=true/false, ... }.
--    없으면 Tools 폴더 존재 여부로 equip 가능 여부를 자동 추론합니다.

DEBUG = true  -- 디버그 출력(텍스트). Studio Output에서 동작 확인에 사용.

--// 서비스 참조
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ContextActionService = game:GetService("ContextActionService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService") -- (향후 슬롯 애니메이션용)

local LOCAL_PLAYER = Players.LocalPlayer

-- 기본 백팩 UI가 숫자키를 선점하지 않도록 비활성화(안전하게 pcall)
pcall(function()
	game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
end)

-- ===== 설정 =====
-- v1.4.2: 상단 숫자키(1~8)만 사용
local MAX_KEYS = 8
local KEYCODES = {
	Enum.KeyCode.One, Enum.KeyCode.Two, Enum.KeyCode.Three, Enum.KeyCode.Four,
	Enum.KeyCode.Five, Enum.KeyCode.Six, Enum.KeyCode.Seven, Enum.KeyCode.Eight,
}

-- ===== 외부 의존(있으면 사용, 없으면 자동 추론) =====
local Shared = ReplicatedStorage:FindFirstChild("Shared")
local ItemDefsModule = Shared and Shared:FindFirstChild("ItemDefs")
local okDefs, ItemDefs = pcall(function() return ItemDefsModule and require(ItemDefsModule) end)
if not okDefs then ItemDefs = nil end

local ToolsFolder = ReplicatedStorage:FindFirstChild("Tools")

local IconsModule = Shared and Shared:FindFirstChild("ItemIcons")
local okIcons, ItemIcons = pcall(function() return IconsModule and require(IconsModule) end)
if not okIcons then ItemIcons = {} end

-- 최신 FontFace만 사용 (경고 제거)
local function setSemiBoldFont(label: TextLabel)
	label.FontFace = Font.new(
		"rbxasset://fonts/families/GothamSSm.json",
		Enum.FontWeight.SemiBold,
		Enum.FontStyle.Normal
	)
end

-- v1.7.0 ⭐추가: 버튼에 '호버 테두리'를 부착하는 유틸
--  - UIStroke: 기본은 투명(보이지 않음), 마우스 진입 시만 살짝 표시
--  - UICorner: 모서리 둥글게(슬롯 미관 개선)
local function attachHoverStroke(button: GuiObject)
	local stroke = Instance.new("UIStroke")
	stroke.Name = "HoverStroke"
	stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	stroke.Thickness = 2
	stroke.Color = Color3.fromRGB(255, 255, 255)
	stroke.Transparency = 1 -- 평소엔 숨김
	stroke.Parent = button

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = button

	button.MouseEnter:Connect(function()
		stroke.Transparency = 0.4 -- 호버 시 은은한 테두리
	end)
	button.MouseLeave:Connect(function()
		stroke.Transparency = 1
	end)
end

-- ===== 내부 상태 =====
local screenGui : ScreenGui
local barFrame : Frame
local slotButtons : {ImageButton} = {}
local slotCountTexts : {TextLabel} = {}
local order : {string} = {}         -- 화면에 보이는 순서대로의 itemId 리스트
local slotById : {[string]: {valueObj: IntValue?, last: number}} = {}
local equippedId : string? = nil     -- 현재 장착 중인 Tool 이름(또는 nil)


-- v1.5.0 ⭐추가: 획득 순서(세션 내 고정)용 Attribute 키
local ORDER_ATTR = "HB_Order"
local NEXT_ORDER_ATTR = "HB_NextOrder"

-- v1.5.0 ⭐추가: 다음 순번 확보(없으면 1부터 시작)
local function ensureNextOrderAttr(inv: Instance): number
	local n = inv:GetAttribute(NEXT_ORDER_ATTR)
	if typeof(n) ~= "number" then
		inv:SetAttribute(NEXT_ORDER_ATTR, 1)
		n = 1
	end
	return n
end

-- v1.5.0 ⭐추가: 아이템(IntValue)에 최초 등장시만 순번 부여
local function assignOrderIfNeeded(inv: Instance, vobj: IntValue)
	if vobj:GetAttribute(ORDER_ATTR) then return end
	local nextIdx = ensureNextOrderAttr(inv)
	vobj:SetAttribute(ORDER_ATTR, nextIdx)         -- 이 아이템의 순서 확정
	inv:SetAttribute(NEXT_ORDER_ATTR, nextIdx + 1) -- 다음 순서 증가
	if DEBUG then
		warn(("HotbarClient v1.5.0: assign order %d to %s"):format(nextIdx, vobj.Name))
	end
end

-- (선언만 먼저: 일부 콜백에서 참조)
-- v1.4.2a 교체: 중복 정의 방지. '함수 정의'가 아니라 '변수 전방 선언'만 남깁니다.
local equipByIndex -- : (idx: number) -> ()  -- 타입 느낌의 주석일 뿐, 실제 문법 영향 없음

-- v1.6.1 ⭐추가: buildEmptySlot에서 사용하므로 전방 선언만 먼저
local unequipAll   -- : () -> ()
local highlightIndex -- : (idx: number?) -> ()

-- ===== 유틸 =====
local function getItemDef(id: string)
	if ItemDefs and ItemDefs[id] then
		return ItemDefs[id]
	end
	local def = {}
	def.equip = (ToolsFolder and ToolsFolder:FindFirstChild(id)) and true or false
	return def
end

-- v1.9.0 ⭐추가: 아이템 표시 이름 헬퍼
--  - ItemDefs[id].displayName 가 있으면 그것을, 없으면 원래 id 사용
local function getDisplayName(id: string): string
	local d = (ItemDefs and ItemDefs[id]) or nil
	if d and typeof(d.displayName) == "string" and #d.displayName > 0 then
		return d.displayName
	end
	return id
end

-- GUI 생성(한 번만)
local function ensureGui()
	if screenGui then return end

	screenGui = Instance.new("ScreenGui")
	screenGui.Name = "HotbarGui"
	screenGui.ResetOnSpawn = false
	screenGui.IgnoreGuiInset = true
	screenGui.Parent = LOCAL_PLAYER:WaitForChild("PlayerGui")

	-- 하단 중앙 정렬용 프레임(너비는 아이템 수에 따라 동적)
	barFrame = Instance.new("Frame")
	barFrame.Name = "Bar"
	barFrame.AnchorPoint = Vector2.new(0.5, 1)
	barFrame.Position = UDim2.new(0.5, 0, 1, -12)
	barFrame.Size = UDim2.new(0, 0, 0, 64) -- 실제 너비는 rebuild 시 계산
	barFrame.BackgroundTransparency = 1
	barFrame.Parent = screenGui
end

-- 슬롯 버튼 하나 생성
-- v1.8.0 교체: 아이템 슬롯도 키캡 표시 + 회색 배경 유지 + 아이콘만 얹기
-- v1.9.0 교체: 중앙 이름 라벨(ItemName) 추가 + 기존 스타일 유지
local function buildSlot(idx: number, id: string, count: number)
	-- 버튼 본체(배경은 항상 회색 유지)
	local btn = Instance.new("ImageButton")
	btn.Name = ("Slot_%d"):format(idx)
	btn.Size = UDim2.new(0, 56, 0, 56)
	btn.Position = UDim2.new(0, (idx-1)*60, 0, 4)
	btn.AutoButtonColor = true
	btn.BackgroundColor3 = Color3.fromRGB(40,40,40)
	btn.BackgroundTransparency = 0
	btn.BorderSizePixel = 0
	btn.Image = ""
	btn.Parent = barFrame

	attachHoverStroke(btn) -- 호버 테두리

	-- 아이콘(있으면 내부 ImageLabel로만 표시, 여백 포함)
	local iconId = ItemIcons[id]
	local hasIcon = (typeof(iconId) == "string" and #iconId > 0)
	if hasIcon then
		local icon = Instance.new("ImageLabel")
		icon.Name = "Icon"
		icon.BackgroundTransparency = 1
		icon.Size = UDim2.new(1, -10, 1, -10)  -- 패딩 5px
		icon.Position = UDim2.new(0, 5, 0, 5)
		icon.Image = iconId
		icon.ScaleType = Enum.ScaleType.Fit
		icon.ZIndex = 1
		icon.Parent = btn
	end
	-- (아이콘이 없어도 이제는 중앙 이름 라벨을 사용하므로, 이전의 상단 이름 라벨은 만들지 않습니다)

	-- 상단 좌측: 회색 키캡(슬롯 번호)
	local keycap = Instance.new("TextLabel")
	keycap.Name = "Keycap"
	keycap.BackgroundTransparency = 1
	keycap.Size = UDim2.new(0, 16, 0, 14)
	keycap.Position = UDim2.new(0, 4, 0, 2)
	keycap.Text = tostring(idx)
	keycap.TextColor3 = Color3.fromRGB(180,180,180)
	keycap.TextScaled = true
	setSemiBoldFont(keycap)
	keycap.ZIndex = 3
	keycap.Parent = btn

	-- ★ v1.9.0 추가: 중앙 이름 라벨(아이템 표시 이름)
	local nameMid = Instance.new("TextLabel")
	nameMid.Name = "ItemName"
	nameMid.BackgroundTransparency = 1
	nameMid.AnchorPoint = Vector2.new(0.5, 0.5)
	nameMid.Position = UDim2.new(0.5, 0, 0.5, 0)           -- 정확히 중앙
	nameMid.Size = UDim2.new(2, -8, 0, 40)                 -- 가로 여백 4px씩
	nameMid.Text = getDisplayName(id)                      -- 표시에 더 예쁜 이름
	nameMid.TextColor3 = Color3.fromRGB(235,235,235)       -- 밝은 회색
	nameMid.TextStrokeTransparency = 0.4                   -- 외곽선으로 가독성 ↑
	nameMid.TextScaled = true                              -- 길면 자동 축소
	nameMid.TextWrapped = false
	nameMid.ZIndex = 3                                     -- 아이콘 위
	setSemiBoldFont(nameMid)
	nameMid.Parent = btn

	-- 우하단 수량
	local t = Instance.new("TextLabel")
	t.Name = "Count"
	t.AnchorPoint = Vector2.new(1,1)
	t.Position = UDim2.new(1, -4, 1, -4)
	t.Size = UDim2.new(0, 36, 0, 18)
	t.BackgroundTransparency = 1
	t.TextColor3 = Color3.new(1,1,1)
	t.TextStrokeTransparency = 0.5
	t.TextScaled = true
	setSemiBoldFont(t)
	t.Text = tostring(count or 0)
	t.ZIndex = 3
	t.Parent = btn

	-- 선택 하이라이트(하단 바)
	local hl = Instance.new("Frame")
	hl.Name = "HL"
	hl.BackgroundColor3 = Color3.fromRGB(255, 170, 60)
	hl.BackgroundTransparency = 0.5
	hl.BorderSizePixel = 0
	hl.Size = UDim2.new(1, 0, 0, 3)
	hl.Position = UDim2.new(0, 0, 1, -3)
	hl.Visible = false
	hl.ZIndex = 4
	hl.Parent = btn

	slotButtons[idx] = btn
	slotCountTexts[idx] = t

	-- 클릭 핸들러
	local idxCopy = idx
	btn.MouseButton1Click:Connect(function()
		equipByIndex(idxCopy)
	end)
end


-- v1.6.0 ⭐추가: 아이템이 없는 빈 칸 슬롯(플레이스홀더) 생성
--  - 클릭 시 장착 해제(unequipAll)만 수행, 하이라이트 없음
local function buildEmptySlot(idx: number)
	local btn = Instance.new("ImageButton")
	btn.Name = ("Slot_%d_Empty"):format(idx)
	btn.Size = UDim2.new(0, 56, 0, 56)
	btn.Position = UDim2.new(0, (idx-1)*60, 0, 4)
	btn.AutoButtonColor = false
	btn.BackgroundColor3 = Color3.fromRGB(40,40,40)
	btn.BorderSizePixel = 0
	btn.Image = ""
	btn.Parent = barFrame
	
	-- v1.7.0 ⭐추가: 호버 테두리(아이템 슬롯과 동일)
	attachHoverStroke(btn)

	-- 그래도 일관성을 위해 HL 프레임은 만들어 두되, 사용할 일은 없음
	local hl = Instance.new("Frame")
	hl.Name = "HL"
	hl.BackgroundColor3 = Color3.fromRGB(255, 170, 60)
	hl.BackgroundTransparency = 0.5
	hl.BorderSizePixel = 0
	hl.Size = UDim2.new(1, 0, 0, 3)
	hl.Position = UDim2.new(0, 0, 1, -3)
	hl.Visible = false
	hl.Parent = btn
	
	-- v1.7.0 ⭐추가: 좌측 상단 작은 회색 숫자 키캡(1~8)
	local keycap = Instance.new("TextLabel")
	keycap.Name = "Keycap"
	keycap.BackgroundTransparency = 1
	keycap.Size = UDim2.new(0, 16, 0, 14) -- 작고 깔끔하게
	keycap.Position = UDim2.new(0, 4, 0, 2)
	keycap.Text = tostring(idx)
	keycap.TextColor3 = Color3.fromRGB(180,180,180) -- 회색
	keycap.TextScaled = true
	setSemiBoldFont(keycap)
	keycap.Parent = btn

	slotButtons[idx] = btn
	slotCountTexts[idx] = nil

	btn.MouseButton1Click:Connect(function()
		-- 빈 슬롯 클릭 시: 모든 장착 해제 + 하이라이트 해제
		unequipAll()
		highlightIndex(nil)
	end)
end

-- 바 프레임 초기화(모든 슬롯 제거)
local function clearBar()
	for _,b in ipairs(slotButtons) do
		if b then b:Destroy() end
	end
	slotButtons = {}
	slotCountTexts = {}
end

-- 모든 Tool 해제 + 하이라이트 끄기
-- 모든 Tool 해제 + 하이라이트 끄기
-- v1.6.1 교체: 위 전방 선언(local unequipAll)에 '대입'되도록 local 제거
function unequipAll()
	local char = LOCAL_PLAYER.Character
	local hum = char and char:FindFirstChildOfClass("Humanoid")
	if hum then hum:UnequipTools() end
	equippedId = nil
	for _,btn in ipairs(slotButtons) do
		local hl = btn and btn:FindFirstChild("HL")
		if hl then hl.Visible = false end
	end
end


-- 특정 슬롯만 하이라이트
-- v1.6.1 교체: 위 전방 선언(local highlightIndex)에 '대입'되도록 local 제거
function highlightIndex(idx: number?)
	for i,btn in ipairs(slotButtons) do
		local hl = btn and btn:FindFirstChild("HL")
		if hl then hl.Visible = (idx ~= nil and i == idx) end
	end
end

-- Tool 장착(Backpack에 없으면 Tools 프리팹에서 복제하여 지급 후 장착)
local function equipToolById(id: string)
	local def = getItemDef(id)
	if not def or not def.equip then return false end

	unequipAll()

	local backpack = LOCAL_PLAYER:WaitForChild("Backpack")
	local char = LOCAL_PLAYER.Character
	local hum = char and char:FindFirstChildOfClass("Humanoid")

	local tool = (backpack:FindFirstChild(id)) or (char and char:FindFirstChild(id))
	if not tool then
		local prefab = ToolsFolder and ToolsFolder:FindFirstChild(id)
		if prefab then
			tool = prefab:Clone()
			tool.Parent = backpack
		else
			return false
		end
	end

	if hum then
		hum:EquipTool(tool)
		equippedId = id
		return true
	end
	return false
end

-- 화면 순서(order)에 맞춰 전체 UI 재구성
local function rebuildOrderAndUI()
	ensureGui()
	order = {}

	-- 인벤토리 확보(없으면 생성)
	local inv = LOCAL_PLAYER:FindFirstChild("Inventory")
	if not inv then
		inv = Instance.new("Folder")
		inv.Name = "Inventory"
		inv.Parent = LOCAL_PLAYER
	end

	-- v1.6.0 교체: 8칸을 항상 표시(아이템 없는 칸은 빈 슬롯) + 중앙 정렬 폭 고정
	local entries = {}
	for _,v in ipairs(inv:GetChildren()) do
		if v:IsA("IntValue") then
			local id = v.Name
			local def = getItemDef(id)
			local count = v.Value or 0
			-- 장착 불가 아이템은 수량 0이면 표시 X (규칙 유지)
			if (def.equip) or (count > 0) then
				assignOrderIfNeeded(inv, v) -- 최초 본 아이템이면 순번 부여
				local ord = v:GetAttribute(ORDER_ATTR) or math.huge
				table.insert(entries, { id = id, ord = ord })
				slotById[id] = { valueObj = v, last = count }
			end
		end
	end

	table.sort(entries, function(a,b)
		if a.ord ~= b.ord then return a.ord < b.ord end
		return a.id < b.id
	end)

	clearBar()

	-- ⭐폭을 MAX_KEYS 기준으로 고정 → 항상 중앙
	local SLOT_W, GAP = 56, 4
	local PITCH = SLOT_W + GAP
	local totalW = (MAX_KEYS * PITCH) - GAP
	barFrame.Size = UDim2.new(0, totalW, 0, 64)

	-- ⭐슬롯 1~MAX_KEYS까지 생성: 앞에서부터 아이템 → 나머지는 빈칸
	order = {} -- 아이템만 연속으로 담는다(빈칸은 넣지 않음)
	for i = 1, MAX_KEYS do
		local e = entries[i]
		if e then
			local id = e.id
			table.insert(order, id) -- 1..#items 연속
			local vobj = slotById[id] and slotById[id].valueObj
			local cnt = (vobj and vobj.Value) or 0
			buildSlot(i, id, cnt)
		else
			buildEmptySlot(i)
		end
	end


end

-- 슬롯 인덱스로 선택/장착
function equipByIndex(idx: number)
	local id = order[idx]
	if not id then
		unequipAll()
		return
	end

	local def = getItemDef(id)
	if def.equip then
		if equipToolById(id) then
			highlightIndex(idx)
		else
			unequipAll()
		end
	else
		unequipAll()
		highlightIndex(idx)
	end
end

-- 인벤토리 수량 변화 감지 → 텍스트만 갱신, 필요 시 전체 리빌드
local function onInventoryChanged()
	local inv = LOCAL_PLAYER:FindFirstChild("Inventory")
	if not inv then return end

	-- 수량 텍스트 갱신
	for idx,id in ipairs(order) do
		local vobj = inv:FindFirstChild(id)
		if vobj and vobj:IsA("IntValue") then
			local cnt = vobj.Value
			local lbl = slotCountTexts[idx]
			if lbl then lbl.Text = tostring(cnt) end
			if slotById[id] then slotById[id].last = cnt end
		end
	end

	-- 표시/숨김 조건 변동 체크
	local needRebuild = false
	for _,v in ipairs(inv:GetChildren()) do
		if v:IsA("IntValue") then
			local id = v.Name
			local def = getItemDef(id)
			local cnt = v.Value
			if not def.equip and cnt <= 0 then
				needRebuild = true
			end
		end
	end
	if needRebuild then
		rebuildOrderAndUI()
	end
end

-- 인벤토리 감시 시작(ChildAdded/Removed/Changed)
-- v1.5.0 교체: 초기 스캔 때도 순서 부여, ChildAdded 때도 즉시 부여
local function startInventoryWatch()
	local inv = LOCAL_PLAYER:FindFirstChild("Inventory")
	if not inv then
		inv = Instance.new("Folder"); inv.Name = "Inventory"; inv.Parent = LOCAL_PLAYER
	end

	-- 다음 순번 보장(없으면 1)
	ensureNextOrderAttr(inv)

	-- 초기 아이템에도 순서 없으면 부여
	for _,v in ipairs(inv:GetChildren()) do
		if v:IsA("IntValue") then
			assignOrderIfNeeded(inv, v) -- ⭐처음 로드 시에도 순서 확정
		end
	end

	rebuildOrderAndUI()

	inv.ChildAdded:Connect(function(ch)
		if ch:IsA("IntValue") then
			assignOrderIfNeeded(inv, ch) -- ⭐새로 들어온 아이템에 순서 확정
			rebuildOrderAndUI()
			ch.Changed:Connect(onInventoryChanged)
		end
	end)

	inv.ChildRemoved:Connect(function(_ch)
		rebuildOrderAndUI()
	end)

	for _,v in ipairs(inv:GetChildren()) do
		if v:IsA("IntValue") then
			v.Changed:Connect(onInventoryChanged)
		end
	end
end


-- ===== 숫자키 바인딩(핵심) =====
-- v1.4.2: 상단 숫자키만 바인딩 + 폴백도 상단 숫자키만 검사
local _fallbackConn : RBXScriptConnection? = nil

local function bindNumberKeys()
	-- 1) 기존 바인딩 해제
	for i = 1, MAX_KEYS do
		local actionName = ("Hotbar_%d"):format(i)
		pcall(function() ContextActionService:UnbindAction(actionName) end)
	end
	if _fallbackConn then _fallbackConn:Disconnect() _fallbackConn = nil end

	-- 2) 컨텍스트 액션(우선순위 높음)으로 상단 숫자키 1:1 바인딩
	for i = 1, MAX_KEYS do
		local actionName = ("Hotbar_%d"):format(i)
		local idxCopy = i
		local keycode = KEYCODES[i]
		if keycode then
			local priority = Enum.ContextActionPriority.High.Value + 1500
			ContextActionService:BindActionAtPriority(
				actionName,
				function(_, state, _input)
					-- 채팅/텍스트박스 포커스면 통과
					if UserInputService:GetFocusedTextBox() then
						return Enum.ContextActionResult.Pass
					end
					if state ~= Enum.UserInputState.Begin then
						return Enum.ContextActionResult.Pass
					end
					if DEBUG then
						warn(("HotbarClient v1.4.2: key -> slot %d"):format(idxCopy))
					end
					equipByIndex(idxCopy)
					return Enum.ContextActionResult.Sink
				end,
				false,
				priority,
				keycode -- 상단 숫자키만
			)
		end
	end

	-- 3) 폴백: 드물게 선점된 경우를 대비 (상단 숫자키만 체크)
	-- v1.4.3 교체: 폴백을 "항상" 받도록 강화(게임처리 여부 무시) + 키보드 입력만 필터
	_fallbackConn = UserInputService.InputBegan:Connect(function(input: InputObject, _gameProcessed: boolean)
		-- 채팅/입력란이 포커스면 통과 (채팅 타이핑 보호)
		if UserInputService:GetFocusedTextBox() then return end
		-- 키보드 입력만 처리 (패드/마우스 등 제외)
		if input.UserInputType ~= Enum.UserInputType.Keyboard then return end

		local kc = input.KeyCode
		for i = 1, MAX_KEYS do
			local keycode = KEYCODES[i]
			if keycode and kc == keycode then
				if DEBUG then
					warn(("HotbarClient v1.4.3 (fallback-force): key -> slot %d"):format(i))
				end
				equipByIndex(i)
				return
			end
		end
	end)


	if DEBUG then
		warn("HotbarClient v1.4.2: number-key bindings (top row) are (re)applied.")
	end
end

-- ===== 시작 =====
ensureGui()
startInventoryWatch()
bindNumberKeys()

-- 리스폰 시 PlayerModule가 입력을 다시 세팅할 수 있어, 다음 틱에 재바인딩
LOCAL_PLAYER.CharacterAdded:Connect(function()
	task.defer(bindNumberKeys)
end)
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
</roblox>